# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-12-10 08:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Apache Kafka Reference Guide"
msgstr "Guía de referencia de Apache Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr "Esta guía de referencia demuestra cómo su aplicación Quarkus puede utilizar SmallRye Reactive Messaging para interactuar con Apache Kafka."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "Introduction"
msgstr "Introducción"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.\n"
"It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.\n"
"Similar to a message queue, or an enterprise messaging platform, it lets you:"
msgstr "link:https://kafka.apache.org[Apache Kafka] es una popular plataforma de streaming de eventos distribuidos de código abierto. Se utiliza habitualmente para canalizaciones de datos de alto rendimiento, análisis de streaming, integración de datos y aplicaciones de misión crítica. Similar a una cola de mensajes, o una plataforma de mensajería empresarial, le permite:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*publish* (write) and *subscribe* to (read) streams of events, called _records_."
msgstr "*publicar* (escribir) y *suscribirse* (leer) a flujos de eventos, denominados _registros_ ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*store* streams of records durably and reliably inside _topics_."
msgstr "*almacenar* flujos de registros de forma duradera y fiable dentro de _los temas_ ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*process* streams of records as they occur or retrospectively."
msgstr "*procesar* flujos de registros a medida que se producen o retrospectivamente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner."
msgstr "Y toda esta funcionalidad se proporciona de forma distribuida, altamente escalable, elástica, tolerante a fallos y segura."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Quarkus Extension for Apache Kafka"
msgstr "Extensión de Quarkus para Apache Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.\n"
"Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr "Quarkus proporciona soporte para Apache Kafka a través del marco de mensajería reactiva link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye] . Basado en la especificación 2.0 de Eclipse MicroProfile Reactive Messaging, propone un modelo de programación flexible que tiende un puente entre la CDI y la basada en eventos."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.\n"
"For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."
msgstr "Esta guía proporciona una mirada en profundidad sobre Apache Kafka y el framework SmallRye Reactive Messaging. Para un inicio rápido eche un vistazo a xref:kafka-reactive-getting-started.adoc[Introducción a SmallRye Reactive Messaging con Apache Kafka] ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:"
msgstr "Puede añadir las extensiones de `smallrye-reactive-messaging-kafka` a su proyecto ejecutando el siguiente comando en el directorio base de su proyecto:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
msgid "This will add the following to your build file:"
msgstr "Esto añadirá lo siguiente a su archivo de construcción:"

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The extension includes `kafka-clients` version 3.2.1 as a transitive dependency and is compatible with Kafka brokers version 2.x."
msgstr "La extensión incluye la versión 3.1.0 de `kafka-clients` como dependencia transitiva y es compatible con los brokers de Kafka versión 2.x."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Configuring Smallrye Kafka Connector"
msgstr "Configuración del conector Kafka de Smallrye"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr "Dado que el marco de mensajería reactiva de Smallrye soporta diferentes backends de mensajería como Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., emplea un vocabulario genérico:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_."
msgstr "Las aplicaciones envían y reciben *mensajes*. Un mensaje envuelve una _carga útil_ y puede ampliarse con algunos _metadatos_. Con el conector Kafka, un _mensaje_ corresponde a un _registro_ Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_."
msgstr "Los mensajes transitan por *los* canales. Los componentes de la aplicación se conectan a los canales para publicar y consumir mensajes. El conector Kafka asigna _canales_ a _temas_ Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`."
msgstr "Los canales se conectan a los backends de mensajes mediante *conectores*. Los conectores se configuran para asignar los mensajes entrantes a un canal específico (consumido por la aplicación) y recoger los mensajes salientes enviados a un canal específico. Cada conector está dedicado a una tecnología de mensajería específica. Por ejemplo, el conector que se ocupa de Kafka se llama `smallrye-kafka`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "A minimal configuration for the Kafka connector with an incoming channel looks like the following:"
msgstr "Una configuración mínima para el conector Kafka con un canal de entrada tiene el siguiente aspecto:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.\n"
"In dev mode and when running tests, <<kafka-dev-services>> automatically starts a Kafka broker.\n"
"When not provided this property defaults to `localhost:9092`."
msgstr "Configure la ubicación del corredor para el perfil de producción. Puede configurarlo globalmente o por canal utilizando la propiedad `mp.messaging.incoming.$channel.bootstrap.servers` . En modo dev y al ejecutar pruebas, <<kafka-dev-services>> inicia automáticamente un corredor Kafka. Cuando no se proporciona esta propiedad, el valor por defecto es `localhost:9092` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Configure the connector to manage the prices channel. By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Configure el conector para gestionar el canal de precios. Por defecto, el nombre del tema es el mismo que el del canal. Puede configurar el atributo del tema para anularlo."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "El prefijo `%prod` indica que la propiedad sólo se utiliza cuando la aplicación se ejecuta en modo prod (es decir, no en dev o test). Consulte la  link:config-reference.html#profiles[documentación del perfil] para obtener más detalles."

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "Connector auto-attachment"
msgstr "Conexión automática de los conectores"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If you have a single connector on your classpath, you can omit the `connector` attribute configuration.\n"
"Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.\n"
"_Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer."
msgstr "Si tiene un único conector en su classpath, puede omitir la configuración del atributo `connector` . Quarkus asocia automáticamente los canales _huérfanos_ al conector (único) que se encuentra en el classpath. Los canales _huérfanos_ son canales salientes sin un consumidor descendente o canales entrantes sin un productor ascendente."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
msgid "This auto-attachment can be disabled using:"
msgstr "Esta autoadhesión se puede desactivar mediante:"

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Receiving messages from Kafka"
msgstr "Recepción de mensajes de Kafka"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:"
msgstr "Continuando con la configuración mínima anterior, su aplicación Quarkus puede recibir la carga útil de los mensajes directamente:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "There are several other ways your application can consume incoming messages:"
msgstr "Existen otras formas en las que tu aplicación puede consumir los mensajes entrantes:"

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Message"
msgstr "Mensaje"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.\n"
"We'll explore different acknowledgment strategies in <<commit-strategies>>."
msgstr "El tipo `Message` permite al método consumidor acceder a los metadatos del mensaje entrante y gestionar el acuse de recibo manualmente. Exploraremos diferentes estrategias de acuse de recibo en <<commit-strategies>> ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you want to access the Kafka record objects directly, use:"
msgstr "Si quiere acceder directamente a los objetos de registro de Kafka, utilice"

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "ConsumerRecord"
msgstr "ConsumerRecord"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.\n"
"Another simpler approach consists in using `Record`:"
msgstr "`ConsumerRecord` lo proporciona el cliente Kafka subyacente y puede inyectarse directamente en el método consumidor. Otro enfoque más sencillo consiste en utilizar `Record` :"

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Record"
msgstr "Registro"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`Record` is a simple wrapper around key and payload of the incoming Kafka record."
msgstr "`Record` es una simple envoltura alrededor de la clave y la carga útil del registro Kafka entrante."

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "@Channel"
msgstr "@Canal"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:"
msgstr "Alternativamente, tu aplicación puede inyectar un `Multi` en tu bean y suscribirse a sus eventos como en el siguiente ejemplo:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This is a good example of how to integrate a Kafka consumer with another downstream,\n"
"in this example exposing it as a Server-Sent Events endpoint."
msgstr "Este es un buen ejemplo de cómo integrar un consumidor Kafka con otro descendente, en este ejemplo exponiéndolo como un punto final de Eventos Enviados por el Servidor."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When consuming messages with `@Channel`, the application code is responsible for the subscription.\n"
"In the example above, the RESTEasy Reactive endpoint handles that for you."
msgstr "Al consumir mensajes con `@Channel` , el código de la aplicación es responsable de la suscripción. En el ejemplo anterior, el punto final de RESTEasy Reactive se encarga de ello por usted."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Following types can be injected as channels:"
msgstr "Los siguientes tipos pueden ser inyectados como canales:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.\n"
"If you injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting.\n"
"We will explore sending broadcast messages in <<broadcasting-messages-on-multiple-consumers>>."
msgstr "Como en el ejemplo anterior de `Message` , si su canal inyectado recibe cargas útiles ( `Multi<T>` ), acusará recibo del mensaje automáticamente y admitirá múltiples suscriptores. Si su canal inyectado recibe mensajes ( `Multi<Message<T>>` ), será responsable del acuse de recibo y de la difusión. Exploraremos el envío de mensajes de difusión en <<broadcasting-messages-on-multiple-consumers>> ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Injecting `@Channel(\"prices\")` or having `@Incoming(\"prices\")` does not automatically configure the application to consume messages from Kafka.\n"
"You need to configure an inbound connector with `mp.messaging.incoming.prices\\...` or have an `@Outgoing(\"prices\")` method somewhere in your application (in which case, `prices` will be an in-memory channel)."
msgstr "Inyectar `@Channel(\"prices\")` o tener `@Incoming(\"prices\")` no configura automáticamente la aplicación para consumir mensajes de Kafka. Necesita configurar un conector de entrada con `mp.messaging.incoming.prices...` o tener un método `@Outgoing(\"prices\")` en algún lugar de su aplicación (en cuyo caso, `prices` será un canal en memoria)."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Blocking processing"
msgstr "Bloqueo del tratamiento"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Reactive Messaging invokes your method on an I/O thread.\n"
"See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.\n"
"But, you often need to combine Reactive Messaging with blocking processing such as database interactions.\n"
"For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread."
msgstr "La Mensajería Reactiva invoca su método en un hilo de E/S. Consulte la xref:quarkus-reactive-architecture.adoc[documentación de la Arquitectura Reactiva de Quarkus] para más detalles sobre este tema. Pero, a menudo necesita combinar la Mensajería Reactiva con el procesamiento de bloqueo, como las interacciones con la base de datos. Para ello, necesita utilizar la anotación `@Blocking` indicando que el procesamiento es _bloqueante_ y no debe ejecutarse en el hilo de llamada."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "Por ejemplo, el siguiente código ilustra cómo puede almacenar las cargas útiles entrantes en una base de datos utilizando Hibernate con Panache:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The complete example is available in the `kafka-panache-quickstart` link:{quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "El ejemplo completo está disponible en `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directorio]."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
msgid "There are 2 `@Blocking` annotations:"
msgstr "Hay 2 anotaciones en `@Blocking`:"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"They have the same effect.\n"
"Thus, you can use both.\n"
"The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.\n"
"The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "Tienen el mismo efecto. Por lo tanto, puede utilizar ambos. El primero proporciona un ajuste más fino, como la reserva de trabajadores a utilizar y si preserva el orden. El segundo, utilizado también con otras características reactivas de Quarkus, utiliza el pool de trabajadores por defecto y preserva el orden."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/blocking/[SmallRye Reactive Messaging – Handling blocking execution]."
msgstr "Puede encontrar información detallada sobre el uso de la anotación `@Blocking` en  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging - Handling blocking execution]."

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "@RunOnVirtualThread"
msgstr "@RunOnVirtualThread"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For running the blocking processing on Java _virtual threads_, see the xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support with Reactive Messaging documentation]."
msgstr "Para ejecutar el procesamiento de bloqueo en _hilos virtuales_ Java, véase la  link:messaging-virtual-threads.html[documentación Quarkus Virtual Thread support with Reactive Messaging]."

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "@Transactional"
msgstr "@Transactional"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
msgid "If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`."
msgstr "Si su método está anotado con `@Transactional`, se considerará automáticamente _bloqueante_, incluso si el método no está anotado con `@Blocking`."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Acknowledgment Strategies"
msgstr "Estrategias de reconocimiento"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"All messages received by a consumer must be acknowledged.\n"
"In the absence of acknowledgment, the processing is considered in error.\n"
"If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.\n"
"If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.\n"
"You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`),\n"
"or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:"
msgstr "Todos los mensajes recibidos por un consumidor deben ser acusados de recibo. En ausencia de acuse de recibo, el procesamiento se considera erróneo. Si el método consumidor recibe un `Record` o una carga útil, el mensaje será acuse de recibo al retorno del método, también conocido como `Strategy.POST_PROCESSING` . Si el método consumidor devuelve otro flujo reactivo o `CompletionStage` , el mensaje se acogerá cuando se acoja el mensaje descendente. Puede anular el comportamiento por defecto para ack el mensaje a su llegada ( `Strategy.PRE_PROCESSING` ), o no ack el mensaje en absoluto ( `Strategy.NONE` ) en el método consumidor como en el siguiente ejemplo:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL`\n"
"and the consumer method is in charge of ack/nack the message."
msgstr "Si el método consumidor recibe un `Message` , la estrategia de acuse de recibo es `Strategy.MANUAL` y el método consumidor se encarga de ack/nack el mensaje."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`."
msgstr "Como se mencionó anteriormente, el método también puede anular la estrategia de reconocimiento a `PRE_PROCESSING` o `NONE`."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Commit Strategies"
msgstr "Estrategias de compromiso"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.\n"
"These strategies decide when the consumer offset for a specific topic/partition is committed.\n"
"Committing an offset indicates that all previous records have been processed.\n"
"It is also the position where the application would restart the processing after a crash recovery or a restart."
msgstr "Cuando se acusa recibo de un mensaje producido a partir de un registro Kafka, el conector invoca una estrategia de consignación. Estas estrategias deciden cuándo se compromete el desplazamiento del consumidor para un tema/partición específico. Comprometer un desplazamiento indica que todos los registros anteriores han sido procesados. También es la posición en la que la aplicación reiniciaría el procesamiento tras una recuperación o un reinicio."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Committing every offset has performance penalties as Kafka offset management can be slow.\n"
"However, not committing the offset often enough may lead to message duplication if the application crashes between two commits."
msgstr "Confirmar cada offset tiene penalizaciones de rendimiento, ya que la gestión de offset de Kafka puede ser lenta. Sin embargo, no consignar el desplazamiento con la frecuencia suficiente puede provocar la duplicación de mensajes si la aplicación se bloquea entre dos consignaciones."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The Kafka connector supports three strategies:"
msgstr "El conector Kafka admite tres estrategias:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`throttled` keeps track of received messages and commits an offset of the latest acked message in sequence (meaning, all previous messages were also acked).\n"
"This strategy guarantees at-least-once delivery even if the channel performs asynchronous processing.\n"
"The connector tracks the received records and periodically (period specified by `auto.commit.interval.ms`, default: 5000 ms) commits the highest consecutive offset.\n"
"The connector will be marked as unhealthy if a message associated with a record is not acknowledged in `throttled.unprocessed-record-max-age.ms` (default: 60000 ms).\n"
"Indeed, this strategy cannot commit the offset as soon as a single record processing fails.\n"
"If `throttled.unprocessed-record-max-age.ms` is set to less than or equal to `0`, it does not perform any health check verification.\n"
"Such a setting might lead to running out of memory if there are \"poison pill\" messages (that are never acked).\n"
"This strategy is the default if `enable.auto.commit` is not explicitly set to true."
msgstr "`throttled` mantiene un registro de los mensajes recibidos y consigna un desplazamiento del último mensaje acuse de recibo en la secuencia (lo que significa que todos los mensajes anteriores también fueron acuse de recibo). Esta estrategia garantiza la entrega al menos una vez, incluso si el canal realiza un procesamiento asíncrono. El conector realiza un seguimiento de los registros recibidos y periódicamente (periodo especificado por `auto.commit.interval.ms` , por defecto: 5000 ms) consigna el desplazamiento consecutivo más alto. El conector se marcará como no sano si un mensaje asociado a un registro no es reconocido en `throttled.unprocessed-record-max-age.ms` (por defecto: 60000 ms). De hecho, esta estrategia no puede consignar el desfase en cuanto falla el procesamiento de un único registro. Si `throttled.unprocessed-record-max-age.ms` se fija en un valor inferior o igual a `0` , no realiza ninguna verificación de chequeo. Una configuración de este tipo podría llevar a quedarse sin memoria si hay mensajes de \"píldora envenenada\" (que nunca se aceptan). Esta estrategia es la predeterminada si `enable.auto.commit` no se establece explícitamente en true."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`checkpoint` allows persisting consumer offsets on a **state store**, instead of committing them back to the Kafka broker.\n"
"Using the `CheckpointMetadata` API, consumer code can persist a _processing state_ with the record offset to mark the progress of a consumer.\n"
"When the processing continues from a previously persisted offset, it seeks the Kafka consumer to that offset and also restores the persisted state, continuing the stateful processing from where it left off.\n"
"The checkpoint strategy holds locally the processing state associated with the latest offset, and persists it periodically to the state store (period specified by `auto.commit.interval.ms` (default: 5000)).\n"
"The connector will be marked as unhealthy if no processing state is persisted to the state store in `checkpoint.unsynced-state-max-age.ms` (default: 10000).\n"
"If `checkpoint.unsynced-state-max-age.ms` is set to less than or equal to 0, it does not perform any health check verification.\n"
"For more information, see <<stateful-processing-checkpointing>>"
msgstr "`checkpoint` permite persistir los desplazamientos de los consumidores en un *almacén de estados* , en lugar de enviarlos de vuelta al corredor de Kafka. Utilizando la API `CheckpointMetadata` , el código del consumidor puede persistir un estado de _procesamiento_ con el desplazamiento de registro para marcar el progreso de un consumidor. Cuando el procesamiento continúa desde un desplazamiento persistido previamente, busca el consumidor Kafka ese desplazamiento y también restaura el estado persistido, continuando el procesamiento con estado desde donde lo dejó. La estrategia de punto de control mantiene localmente el estado de procesamiento asociado al último desplazamiento y lo persiste periódicamente en el almacén de estado (periodo especificado por `auto.commit.interval.ms` (por defecto: 5000)). El conector se marcará como no saludable si no se persiste ningún estado de procesamiento al almacén de estado en `checkpoint.unsynced-state-max-age.ms` (por defecto: 10000). Si `checkpoint.unsynced-state-max-age.ms` es menor o igual a 0, no realiza ninguna verificación de estado. Para más información, consulte <<stateful-processing-checkpointing>>"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).\n"
"This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.\n"
"This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates."
msgstr "`latest` consigna el desplazamiento de registro recibido por el consumidor de Kafka en cuanto se acusa recibo del mensaje asociado (si el desplazamiento es mayor que el consignado anteriormente). Esta estrategia proporciona una entrega al menos una vez si el canal procesa el mensaje sin realizar ningún procesamiento asíncrono. Esta estrategia no debe utilizarse en un entorno de alta carga, ya que la confirmación del desplazamiento es costosa. Sin embargo, reduce el riesgo de duplicados."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.\n"
"It delegates the offset commit to the underlying Kafka client.\n"
"When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.\n"
"SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.\n"
"In case of a failure, only records that were not committed yet will be re-processed."
msgstr "`ignore` no realiza ninguna confirmación. Esta estrategia es la predeterminada cuando el consumidor se configura explícitamente con `enable.auto.commit` a true. Delega la confirmación del desplazamiento al cliente Kafka subyacente. Cuando `enable.auto.commit` es `true` esta estrategia *NO* garantiza la entrega at-least-once. La mensajería reactiva de SmallRye procesa los registros de forma asíncrona, por lo que pueden confirmarse desplazamientos de registros que han sido sondeados pero aún no procesados. En caso de fallo, sólo se volverán a procesar los registros que aún no se hayan consignado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.\n"
"If high throughput is important for you, and you are not limited by the downstream, we recommend to either:"
msgstr "El conector Kafka desactiva el autocompromiso de Kafka cuando no está explícitamente habilitado. Este comportamiento difiere del consumidor Kafka tradicional. Si el alto rendimiento es importante para usted y no está limitado por el flujo descendente, le recomendamos cualquiera de los dos:"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "use the `throttled` policy,"
msgstr "utilizar la política de `throttled`,"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`."
msgstr "o establecer `enable.auto.commit` como verdadero y anotar el método de consumo con `@Acknowledgment(Acknowledgment.Strategy.NONE)`."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Smallrye Reactive Messaging enables implementing custom commit strategies.\n"
"See https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[SmallRye Reactive Messaging documentation] for more information."
msgstr "Smallrye Reactive Messaging permite implementar estrategias de commit personalizadas. Consulte link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[la documentación de SmallRye Re] active Messaging para obtener más información."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Error Handling Strategies"
msgstr "Estrategias de gestión de errores"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:"
msgstr "Si un mensaje producido a partir de un registro de Kafka es nacked, se aplica una estrategia de fallo. El conector Kafka soporta tres estrategias:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed."
msgstr "`fail`: falla la aplicación, no se procesarán más registros (estrategia por defecto). El desplazamiento del registro que no se ha procesado correctamente no se compromete."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed."
msgstr "`ignore`El fallo se registra, pero el procesamiento continúa. Se consigna el desplazamiento del registro que no se ha procesado correctamente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic."
msgstr "`dead-letter-queue`: el desplazamiento del registro que no se ha procesado correctamente se consigna, pero el registro se escribe en un tema de letra muerta de Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The strategy is selected using the `failure-strategy` attribute."
msgstr "La estrategia se selecciona mediante el atributo `failure-strategy`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "In the case of `dead-letter-queue`, you can configure the following attributes:"
msgstr "En el caso de `dead-letter-queue`, puede configurar los siguientes atributos:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel."
msgstr "`dead-letter-queue.topic`: el tema a utilizar para escribir los registros no procesados correctamente, por defecto es `dead-letter-topic-$channel`, siendo `$channel` el nombre del canal."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer."
msgstr "`dead-letter-queue.key.serializer`: el serializador utilizado para escribir la clave de registro en la cola de letra muerta. Por defecto, deduce el serializador del deserializador de la clave."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer."
msgstr "`dead-letter-queue.value.serializer`: el serializador utilizado para escribir el valor del registro en la cola de letra muerta. Por defecto, deduce el serializador del deserializador del valor."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The record written on the dead letter queue contains a set of additional headers about the original record:"
msgstr "El registro escrito en la cola de la letra muerta contiene un conjunto de cabeceras adicionales sobre el registro original:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*dead-letter-reason*: the reason of the failure"
msgstr "*dead-letter-reason* : la razón del fracaso"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*dead-letter-cause*: the cause of the failure if any"
msgstr "*dead-letter-cause* : la causa del fallo si la hay"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*dead-letter-topic*: the original topic of the record"
msgstr "*dead-letter-topic* : el tema original del registro"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*dead-letter-partition*: the original partition of the record (integer mapped to String)"
msgstr "*dead-letter-partition* : la partición original del registro (entero mapeado a String)"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*dead-letter-offset*: the original offset of the record (long mapped to String)"
msgstr "*dead-letter-offset* : el offset original del registro (long mapped to String)"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Smallrye Reactive Messaging enables implementing custom failure strategies.\n"
"See https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[SmallRye Reactive Messaging documentation] for more information."
msgstr "Smallrye Reactive Messaging permite implementar estrategias de fallo personalizadas. Consulte link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[la documentación de SmallRye Re] active Messaging para obtener más información."

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Retrying processing"
msgstr "Reintento de procesamiento"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:"
msgstr "Puede combinar la Mensajería Reactiva con la  link:https://github.com/smallrye/smallrye-fault-tolerance[Tolerancia a Fallos de SmallRye], y reintentar el procesamiento si ha fallado:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can configure the delay, the number of retries, the jitter, etc."
msgstr "Puedes configurar el retraso, el número de reintentos, el jitter, etc."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:"
msgstr "Si su método devuelve un `Uni` o `CompletionStage`, debe añadir la anotación `@NonBlocking`:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.\n"
"Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.\n"
"See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information."
msgstr "La anotación `@NonBlocking` sólo es necesaria con SmallRye Fault Tolerance 5.1.0 y anteriores. A partir de SmallRye Fault Tolerance 5.2.0 (disponible desde Quarkus 2.1.0.Final), no es necesaria. Consulte link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[la documentación] de SmallRye Fault Tolerance para más información."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The incoming messages are acknowledged only once the processing completes successfully.\n"
"So, it commits the offset after the successful processing.\n"
"If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied."
msgstr "Los mensajes entrantes sólo se confirman una vez que el procesamiento se completa con éxito. Por lo tanto, se compromete el desplazamiento después del procesamiento con éxito. Si el procesamiento sigue fallando, incluso después de todos los reintentos, el mensaje es _nacked_ y se aplica la estrategia de fallo."

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Handling Deserialization Failures"
msgstr "Gestión de los fallos de deserialización"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When a deserialization failure occurs, you can intercept it and provide a failure strategy.\n"
"To achieve this, you need to create a bean implementing `DeserializationFailureHandler<T>` interface:"
msgstr "Cuando se produce un fallo de deserialización, puede interceptarlo y proporcionar una estrategia de fallo. Para ello, debe crear un bean que implemente la interfaz `DeserializationFailureHandler<T>` :"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (for key or value deserializers)."
msgstr "Para utilizar este gestor de fallos, el bean debe estar expuesto con el calificador `@Identifier` y la configuración del conector debe especificar el atributo `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (para deserializadores de claves o valores)."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The handler is called with details of the deserialization, including the action represented as `Uni<T>`.\n"
"On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented."
msgstr "Se llama al manejador con los detalles de la deserialización, incluida la acción representada como `Uni<T>` . En la deserialización `Uni` se pueden implementar estrategias de fallo como reintentar, proporcionar un valor de retorno o aplicar un tiempo de espera."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Consumer Groups"
msgstr "Grupos de consumidores"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.\n"
"A topic is divided into a set of partitions.\n"
"The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.\n"
"Note that each partition is assigned to a single consumer from a group.\n"
"However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group."
msgstr "En Kafka, un grupo de consumidores es un conjunto de consumidores que cooperan para consumir datos de un tema. Un tema se divide en un conjunto de particiones. Las particiones de un tema se asignan entre los consumidores del grupo, lo que permite escalar eficazmente el rendimiento del consumo. Tenga en cuenta que cada partición se asigna a un único consumidor de un grupo. Sin embargo, a un consumidor se le pueden asignar varias particiones si el número de particiones es mayor que el número de consumidores del grupo."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:"
msgstr "Exploremos brevemente diferentes patrones de productor/consumidor y cómo implementarlos usando Quarkus:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*Single consumer thread inside a consumer group*"
msgstr "*Un único hilo consumidor dentro de un grupo de consumidores*"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.\n"
"Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.\n"
"It can also be set using the `kafka.group.id` property."
msgstr "Este es el comportamiento por defecto de una aplicación que se suscribe a un tema Kafka: Cada conector Kafka creará un único hilo consumidor y lo colocará dentro de un único grupo consumidor. El identificador del grupo de consumidores es, por defecto, el nombre de la aplicación establecido por la propiedad de configuración `quarkus.application.name` . También puede establecerse mediante la propiedad `kafka.group.id` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*Multiple consumer threads inside a consumer group*"
msgstr "*Múltiples hilos consumidores dentro de un grupo de consumidores*"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.concurrency` property.\n"
"The partitions of the subscribed topic will be divided among the consumer threads.\n"
"Note that if the `concurrency` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions."
msgstr "Para una instancia de aplicación determinada, el número de consumidores dentro del grupo de consumidores puede configurarse utilizando la propiedad `mp.messaging.incoming.$channel.concurrency` . Las particiones del tema suscrito se dividirán entre los hilos consumidores. Tenga en cuenta que si el valor `concurrency` excede el número de particiones del tema, a algunos hilos consumidores no se les asignará ninguna partición."

#. type: Block title
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Deprecation"
msgstr "Depreciación"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The https://smallrye.io/smallrye-reactive-messaging/latest/concepts/incoming-concurrency/[concurrency attribute]\n"
"provides a connector agnostic way for non-blocking concurrent channels and replaces the Kafka connector specific `partitions` attribute.\n"
"The `partitions` attribute is therefore deprecated and will be removed in future releases."
msgstr "El atributo de link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/incoming-concurrency/[concurrencia] proporciona una forma agnóstica del conector para canales concurrentes no bloqueantes y sustituye al atributo `partitions` específico del conector Kafka. Por lo tanto, el atributo `partitions` está obsoleto y se eliminará en futuras versiones."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*Multiple consumer applications inside a consumer group*"
msgstr "*Múltiples aplicaciones para consumidores dentro de un grupo de consumidores*"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.\n"
"This in turn will divide partitions of the topic among application instances."
msgstr "De forma similar al ejemplo anterior, varias instancias de una aplicación pueden suscribirse a un único grupo de consumidores, configurado a través de la propiedad `mp.messaging.incoming.$channel.group.id` , o dejar por defecto el nombre de la aplicación. Esto, a su vez, dividirá las particiones del tema entre las instancias de la aplicación."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "*Pub/Sub: Multiple consumer groups subscribed to a topic*"
msgstr "*Pub/Sub: Múltiples grupos de consumidores suscritos a un tema*"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Lastly different applications can subscribe independently to same topics using different *consumer group ids*.\n"
"For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.\n"
"Different consumer groups can thus scale independently according to the message consumption requirements."
msgstr "Por último, diferentes aplicaciones pueden suscribirse de forma independiente a los mismos temas utilizando diferentes *identificadores de grupo de consumidores* . Por ejemplo, los mensajes publicados en un tema llamado _pedidos_ pueden consumirse independientemente en dos aplicaciones consumidoras, una con `mp.messaging.incoming.orders.group.id=invoicing` y la segunda con `mp.messaging.incoming.orders.group.id=shipping` . De este modo, diferentes grupos de consumidores pueden escalar de forma independiente en función de las necesidades de consumo de mensajes."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"A common business requirement is to consume and process Kafka records in order.\n"
"The Kafka broker preserves order of records inside a partition and not inside a topic.\n"
"Therefore, it is important to think about how records are partitioned inside a topic.\n"
"The default partitioner uses record key hash to compute the partition for a record, or when the key is not defined, chooses a partition randomly per batch or records."
msgstr "Un requisito empresarial habitual es consumir y procesar los registros de Kafka en orden. El corredor Kafka conserva el orden de los registros dentro de una partición y no dentro de un tema. Por lo tanto, es importante pensar en cómo se particionan los registros dentro de un tema. El particionador por defecto utiliza el hash de la clave del registro para calcular la partición de un registro, o cuando la clave no está definida, elige una partición aleatoriamente por lote o registros."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"During normal operation, a Kafka consumer preserves the order of records inside each partition assigned to it.\n"
"Smallrye Reactive Messaging keeps this order for processing, unless `@Blocking(ordered = false)` is used (see <<blocking-processing>>)."
msgstr "Durante el funcionamiento normal, un consumidor Kafka conserva el orden de los registros dentro de cada partición que se le asigna. Smallrye Reactive Messaging mantiene este orden para su procesamiento, a menos que se utilice `@Blocking(ordered = false)` (consulte <<blocking-processing>> )."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Note that due to consumer rebalances, Kafka consumers only guarantee at-least-once processing of single records, meaning that uncommitted records _can_ be processed again by consumers."
msgstr "Tenga en cuenta que, debido a los reequilibrios de los consumidores, los consumidores de Kafka sólo garantizan el procesamiento de una sola vez de los registros individuales, lo que significa que los registros no comprometidos _pueden_ ser procesados de nuevo por los consumidores."

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Consumer Rebalance Listener"
msgstr "Escucha del reequilibrio de los consumidores"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.\n"
"This is known as rebalancing the group.\n"
"To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.\n"
"To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.\n"
"A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset."
msgstr "Dentro de un grupo de consumidores, a medida que llegan nuevos miembros al grupo y se marchan los antiguos, las particiones se reasignan para que cada miembro reciba una parte proporcional de las particiones. Esto se conoce como reequilibrar el grupo. Para gestionar usted mismo el commit de compensación y las particiones asignadas, puede proporcionar un listener de reequilibrio del consumidor. Para ello, implemente la interfaz `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` y expóngala como un bean CDI con el calificador `@Idenfier` . Un caso de uso común es almacenar el desplazamiento en un almacén de datos separado para implementar la semántica \"exactamente una vez\", o iniciar el procesamiento en un desplazamiento específico."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The listener is invoked every time the consumer topic/partition assignment changes.\n"
"For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.\n"
"If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic."
msgstr "La escucha se invoca cada vez que cambia la asignación de temas/particiones del consumidor. Por ejemplo, cuando la aplicación se inicia, invoca la llamada de retorno `partitionsAssigned` con el conjunto inicial de temas/particiones asociados al consumidor. Si, más tarde, este conjunto cambia, vuelve a llamar a las retrollamadas `partitionsRevoked` y `partitionsAssigned` , por lo que puede implementar una lógica personalizada."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.\n"
"That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier."
msgstr "Tenga en cuenta que los métodos de escucha de reequilibrio se llaman desde el hilo de sondeo de Kafka *y* bloquearán el hilo de llamada hasta su finalización. Esto se debe a que el protocolo de reequilibrio tiene barreras de sincronización, y el uso de código asíncrono en un oyente de reequilibrio puede ejecutarse después de la barrera de sincronización."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes."
msgstr "Cuando se asignan o revocan temas/particiones de un consumidor, se pausa la entrega de mensajes y se reanuda una vez completado el reequilibrio."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy),\n"
"the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.\n"
"We also recommend applying the same logic when the application stops."
msgstr "Si el receptor de reequilibrio gestiona la confirmación del reequilibrio en nombre del usuario (utilizando la estrategia de confirmación `NONE` ), el receptor de reequilibrio debe confirmar el reequilibrio de forma sincrónica en la llamada de retorno partitionsRevoked. También recomendamos aplicar la misma lógica cuando se detenga la aplicación."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions."
msgstr "A diferencia del `ConsumerRebalanceListener` de Apache Kafka, los métodos de `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` pasan el consumidor de Kafka y el conjunto de temas/particiones."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In the following example we set up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).\n"
"First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.\n"
"We then must configure our inbound connector to use this bean."
msgstr "En el siguiente ejemplo configuramos un consumidor que siempre se inicia con los mensajes de hace como máximo 10 minutos (o desplazamiento 0). Primero debemos proporcionar un bean que implemente `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` y esté anotado con `io.smallrye.common.annotation.Identifier` . A continuación, debemos configurar nuestro conector de entrada para que utilice este bean."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier:\n"
"`mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"
msgstr "Para configurar el conector de entrada para que utilice el receptor proporcionado, o bien establecemos el identificador del receptor de reequilibrio del consumidor: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Or have the listener’s name be the same as the group id:"
msgstr "O que el nombre del oyente sea el mismo que el identificador del grupo:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"
msgstr "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Setting the consumer rebalance listener’s name takes precedence over using the group id."
msgstr "La configuración del nombre del consumidor de rebalanceo tiene prioridad sobre el uso del id del grupo."

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Using unique consumer groups"
msgstr "Utilizar grupos de consumidores únicos"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you want to process all the records from a topic (from its beginning), you need:"
msgstr "Si quieres procesar todos los registros de un tema (desde su inicio), necesitas:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "to set `auto.offset.reset = earliest`"
msgstr "para establecer `auto.offset.reset = earliest`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "assign your consumer to a consumer group not used by any other application."
msgstr "asignar su consumidor a un grupo de consumidores que no sea utilizado por ninguna otra aplicación."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus generates a UUID that changes between two executions (including in dev mode).\n"
"So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts."
msgstr "Quarkus genera un UUID que cambia entre dos ejecuciones (incluso en modo dev). Así, usted está seguro de que ningún otro consumidor lo utiliza, y recibe un nuevo id de grupo único cada vez que se inicia su aplicación."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can use that generated UUID as the consumer group as follows:"
msgstr "Puede utilizar ese UUID generado como grupo de consumidores de la siguiente manera:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property."
msgstr "Si no se establece el atributo `group.id`, se establece por defecto la propiedad de configuración `quarkus.application.name`."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Manual topic-partition assignment"
msgstr "Asignación manual tema-partición"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `assign-seek` channel attribute allows manually assigning topic-partitions to a Kafka incoming channel,\n"
"and optionally seek to a specified offset in the partition to start consuming records.\n"
"If `assign-seek` is used, the consumer will not be dynamically subscribed to topics,\n"
"but instead will statically assign the described partitions.\n"
"In manual topic-partition rebalancing doesn't happen and therefore rebalance listeners are never called."
msgstr "El atributo de canal `assign-seek` permite asignar manualmente particiones de temas a un canal de entrada Kafka y, opcionalmente, buscar un desplazamiento especificado en la partición para empezar a consumir registros. Si se utiliza `assign-seek` , el consumidor no se suscribirá dinámicamente a los temas, sino que asignará estáticamente las particiones descritas. En el reequilibrio manual de particiones de temas no se produce y, por tanto, nunca se llama a los escuchadores de reequilibrio."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The attribute takes a list of triplets separated by commas: `<topic>:<partition>:<offset>`."
msgstr "El atributo toma una lista de tripletas separadas por comas: `<topic>:<partition>:<offset>` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For example, the configuration"
msgstr "Por ejemplo, la configuración"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "assigns the consumer to:"
msgstr "asigna al consumidor:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Partition 0 of topic 'topic1', setting the initial position at offset 10."
msgstr "Partición 0 del tema 'tema1', fijando la posición inicial en el offset 10."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Partition 1 of topic 'topic2', setting the initial position at offset 20."
msgstr "Partición 1 del tema 'tema2', fijando la posición inicial en el desplazamiento 20."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The topic, partition, and offset in each triplet can have the following variations:"
msgstr "El tema, la partición y el desplazamiento en cada tripleta pueden tener las siguientes variaciones:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the topic is omitted, the configured topic will be used."
msgstr "Si se omite el tema, se utilizará el tema configurado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the offset is omitted, partitions are assigned to the consumer but won't be sought to offset."
msgstr "Si se omite el desplazamiento, las particiones se asignarán al consumidor pero no se buscará el desplazamiento."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If offset is 0, it seeks to the beginning of the topic-partition."
msgstr "Si offset es 0, busca al principio del tema-partición."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If offset is -1, it seeks to the end of the topic-partition."
msgstr "Si offset es -1, busca el final del tema-partición."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Receiving Kafka Records in Batches"
msgstr "Recepción de registros Kafka por lotes"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"By default, incoming methods receive each Kafka record individually.\n"
"Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container."
msgstr "Por defecto, los métodos entrantes reciben cada registro de Kafka individualmente. Bajo el capó, los clientes consumidores de Kafka sondean el corredor constantemente y reciben los registros por lotes, presentados dentro del contenedor `ConsumerRecords` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "In *batch* mode, your application can receive all the records returned by the consumer *poll* in one go."
msgstr "En el modo *por lotes*, su aplicación puede recibir todos los registros devueltos por el *sondeo de* consumidores de una sola vez."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To achieve this you need to specify a compatible container type to receive all the data:"
msgstr "Para ello, es necesario especificar un tipo de contenedor compatible para recibir todos los datos:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The incoming method can also receive `Message<List<Payload>>`, `KafkaRecordBatch<Key, Payload>`, and `ConsumerRecords<Key, Payload>` types.\n"
"They give access to record details such as offset or timestamp:"
msgstr "El método de entrada también puede recibir los tipos `Message<List<Payload>>` , `KafkaRecordBatch<Key, Payload>` y `ConsumerRecords<Key, Payload>` . Permiten acceder a detalles del registro como el desplazamiento o la marca de tiempo:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.\n"
"The configured commit strategy will be applied for these records only."
msgstr "Tenga en cuenta que el procesamiento correcto del lote de registros entrantes consignará las últimas compensaciones para cada partición recibida dentro del lote. La estrategia de consignación configurada se aplicará sólo para estos registros."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Conversely, if the processing throws an exception, all messages are _nacked_, applying the failure strategy for all the records inside the batch."
msgstr "A la inversa, si el procesamiento lanza una excepción, todos los mensajes se _anulan_, aplicando la estrategia de fallo para todos los registros dentro del lote."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.\n"
"You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property."
msgstr "Quarkus autodetecta los tipos de lote para los canales entrantes y establece la configuración de lote automáticamente. Puede configurar el modo por lotes explícitamente con la propiedad `mp.messaging.incoming.$channel.batch` ."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Stateful processing with Checkpointing"
msgstr "Procesamiento por estados con Checkpointing"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The `checkpoint` commit strategy is an experimental feature and can change in the future."
msgstr "La `KafkaClientService` es una API experimental y puede cambiar en el futuro."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Smallrye Reactive Messaging `checkpoint` commit strategy allows consumer applications to process messages in a stateful manner, while also respecting Kafka consumer scalability.\n"
"An incoming channel with `checkpoint` commit strategy persists consumer offsets on an external\n"
"<<state-stores,state store>>, such as a relational database or a key-value store.\n"
"As a result of processing consumed records, the consumer application can accumulate an internal state for each topic-partition assigned to the Kafka consumer.\n"
"This local state will be periodically persisted to the state store and will be associated with the offset of the record that produced it."
msgstr "La estrategia de commit de Smallrye Reactive Messaging `checkpoint` permite a las aplicaciones consumidoras procesar los mensajes de forma que se respete el estado, respetando al mismo tiempo la escalabilidad del consumidor Kafka. Un canal entrante con la estrategia de commit `checkpoint` persiste los registros consumidos en un xref:state-stores[almacén de estado] externo, como una base de datos relacional o un almacén de valores clave. Como resultado del procesamiento de los registros consumidos, la aplicación consumidora puede acumular un estado interno para cada tema-partición asignado al consumidor Kafka. Este estado local se persistirá periódicamente en el almacén de estado y se asociará con el desplazamiento del registro que lo produjo."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This strategy does not commit any offsets to the Kafka broker, so when new partitions get assigned to the consumer,\n"
"i.e. consumer restarts or consumer group instances scale,\n"
"the consumer resumes the processing from the latest _checkpointed_ offset with its saved state."
msgstr "Esta estrategia no compromete ningún desplazamiento en el corredor Kafka, por lo que cuando se asignan nuevas particiones al consumidor, es decir, cuando se reinicia el consumidor o se escalan las instancias del grupo de consumidores, el consumidor reanuda el procesamiento desde el último desplazamiento _comprobado_ con su estado guardado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `@Incoming` channel consumer code can manipulate the processing state through the `CheckpointMetadata` API.\n"
"For example, a consumer calculating the moving average of prices received on a Kafka topic would look the following:"
msgstr "El código del consumidor del canal `@Incoming` puede manipular el estado de procesamiento a través de la API `CheckpointMetadata` . Por ejemplo, un consumidor que calcule la media móvil de los precios recibidos en un tema Kafka tendría el siguiente aspecto:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `transform` method applies the transformation function to the current state, producing a changed state and registering it locally for checkpointing.\n"
"By default, the local state is persisted to the state store periodically, period specified by `auto.commit.interval.ms`, (default: 5000).\n"
"If `persistOnAck` flag is given, the latest state is persisted to the state store eagerly on message acknowledgment.\n"
"The `setNext` method works similarly directly setting the latest state."
msgstr "El método `transform` aplica la función de transformación al estado actual, produciendo un estado modificado y registrándolo localmente para su comprobación. Por defecto, el estado local se persiste en el almacén de estado periódicamente, periodo especificado por `auto.commit.interval.ms` , (por defecto: 5000). Si se indica `persistOnAck` , el estado más reciente se transfiere al almacén de estado de forma inmediata tras el acuse de recibo del mensaje. El método `setNext` funciona de forma similar estableciendo directamente el último estado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The checkpoint commit strategy tracks when a processing state is last persisted for each topic-partition.\n"
"If an outstanding state change can not be persisted for `checkpoint.unsynced-state-max-age.ms` (default: 10000), the channel is marked unhealthy."
msgstr "La estrategia de confirmación de puntos de control rastrea cuándo se persistió por última vez un estado de procesamiento para cada tema-partición. Si no se puede persistir un cambio de estado pendiente para `checkpoint.unsynced-state-max-age.ms` (por defecto: 10000), el canal se marca como no saludable."

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "State stores"
msgstr "Tiendas estatales"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"State store implementations determine where and how the processing states are persisted.\n"
"This is configured by the `mp.messaging.incoming.[channel-name].checkpoint.state-store` property.\n"
"The serialization of state objects depends on the state store implementation.\n"
"In order to instruct state stores for serialization can require configuring the class name of state objects using `mp.messaging.incoming.[channel-name].checkpoint.state-type` property."
msgstr "Las implementaciones del almacén de estados determinan dónde y cómo se persisten los estados de procesamiento. Esto se configura mediante la propiedad `mp.messaging.incoming.[channel-name].checkpoint.state-store` . La serialización de los objetos de estado depende de la implementación del almacén de estado. Para instruir a los almacenes de estado para la serialización puede ser necesario configurar el nombre de clase de los objetos de estado mediante la propiedad `mp.messaging.incoming.[channel-name].checkpoint.state-type` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Quarkus provides following state store implementations:"
msgstr "Quarkus proporciona las siguientes implementaciones de almacenes de estado:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`quarkus-redis`: Uses the xref:redis-reference.adoc[`quarkus-redis-client`] extension to persist processing states.\n"
"Jackson is used to serialize processing state in Json. For complex objects it is required to configure the `checkpoint.state-type` property with the class name of the object.\n"
"By default, the state store uses the default redis client, but if a xref:redis-reference.adoc#default-and-named-clients[named client] is to be used, the client name can be specified using the `mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name` property.\n"
"Processing states will be stored in Redis using the key naming scheme `[consumer-group-id]:[topic]:[partition]`."
msgstr "`quarkus-redis` : Utiliza la xref:redis-reference.adoc[quarkus-redis-client] para persistir los estados de procesamiento. Jackson se utiliza para serializar el estado de procesamiento en Json. Para objetos complejos es necesario configurar la propiedad `checkpoint.state-type` con el nombre de la clase del objeto. Por defecto, el almacén de estados utiliza el cliente redis predeterminado, pero si se desea utilizar un xref:redis-reference.adoc#default-and-named-clients[cliente con nombre] , se puede especificar el nombre del cliente utilizando la propiedad `mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name` . Los estados de procesamiento se almacenarán en Redis utilizando el esquema de nomenclatura de claves `[consumer-group-id]:[topic]:[partition]` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For example the configuration of the previous code would be the following:"
msgstr "Por ejemplo la configuración del código anterior sería la siguiente:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`quarkus-hibernate-reactive`: Uses the xref:hibernate-reactive.adoc[`quarkus-hibernate-reactive`] extension to persist processing states.\n"
"Processing state objects are required to be a Jakarta Persistence entity and extend the `CheckpointEntity` class,\n"
"which handles object identifiers composed of the consumer group id, topic and partition.\n"
"Therefore, the class name of the entity needs to be configured using the `checkpoint.state-type` property."
msgstr "`quarkus-hibernate-reactive` : Utiliza la xref:hibernate-reactive.adoc[quarkus-hibernate-reactive] extensión para persistir estados de procesamiento. Se requiere que los objetos de estado de procesamiento sean una entidad de Jakarta Persistence y extiendan la clase `CheckpointEntity` , que maneja identificadores de objetos compuestos por el id del grupo de consumidores, el tema y la partición. Por lo tanto, es necesario configurar el nombre de la clase de la entidad mediante la propiedad `checkpoint.state-type` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "With `AveragePriceEntity` being a Jakarta Persistence entity extending `CheckpointEntity`:"
msgstr "Siendo `AveragePriceEntity` una entidad JPA que extiende `CheckpointEntity`:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`quarkus-hibernate-orm`: Uses the xref:hibernate-orm.adoc[`quarkus-hibernate-orm`] extension to persist processing states.\n"
"It is similar to the previous state store, but it uses Hibernate ORM instead of Hibernate Reactive."
msgstr "`quarkus-hibernate-orm` : Utiliza la xref:hibernate-orm.adoc[quarkus-hibernate-orm] extensión para persistir los estados de procesamiento. Es similar al almacén de estados anterior, pero utiliza Hibernate ORM en lugar de Hibernate Reactive."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When configured, it can use a named `persistence-unit` for the checkpointing state store:"
msgstr "Cuando está configurado, puede utilizar un nombre `persistence-unit` para el almacén de estado de comprobación:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"For instructions on how to implement custom state stores,\n"
"see https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores[Implementing State Stores]."
msgstr "Para obtener instrucciones sobre cómo implementar link:https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores[almacenes de] estado personalizados, consulte link:https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores[Implementación de almacenes de estado] ."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Sending messages to Kafka"
msgstr "Envío de mensajes a Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Configuration for the Kafka connector outgoing channels is similar to that of incoming:"
msgstr "La configuración de los canales salientes del conector Kafka es similar a la de los entrantes:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.\n"
"In dev mode and when running tests, <<kafka-dev-services>> automatically starts a Kafka broker.\n"
"When not provided, this property defaults to `localhost:9092`."
msgstr "Configure la ubicación del corredor para el perfil de producción. Puede configurarlo globalmente o por canal utilizando la propiedad `mp.messaging.outgoing.$channel.bootstrap.servers` . En modo dev y al ejecutar pruebas, <<kafka-dev-services>> inicia automáticamente un corredor Kafka. Cuando no se proporciona, esta propiedad es por defecto `localhost:9092` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Configure the connector to manage the `prices-out` channel."
msgstr "Configure el conector para gestionar el canal `prices-out`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Por defecto, el nombre del tema es el mismo que el del canal. Puede configurar el atributo de tema para anularlo."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Inside application configuration, channel names are unique.\n"
"Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`)."
msgstr "Dentro de la configuración de la aplicación, los nombres de los canales son únicos. Por lo tanto, si desea configurar un canal entrante y saliente sobre el mismo tema, deberá nombrar los canales de forma diferente (como en los ejemplos de esta guía, `mp.messaging.incoming.prices` y `mp.messaging.outgoing.prices-out` )."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Then, your application can generate messages and publish them to the `prices-out` channel.\n"
"It can use `double` payloads as in the following snippet:"
msgstr "A continuación, su aplicación puede generar mensajes y publicarlos en el canal `prices-out` . Puede utilizar cargas útiles de `double` como en el siguiente fragmento:"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome."
msgstr "No debe llamar a los métodos anotados con `@Incoming` y/o `@Outgoing` directamente desde su código. Son invocados por el framework. Tener código de usuario invocándolos no tendría el resultado esperado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that the `generate` method returns a `Multi<Double>`, which implements the Reactive Streams `Publisher` interface.\n"
"This publisher will be used by the framework to generate messages and send them to the configured Kafka topic."
msgstr "Tenga en cuenta que el método `generate` devuelve un `Multi<Double>` , que implementa la interfaz Reactive Streams `Publisher` . Este publicador será utilizado por el framework para generar mensajes y enviarlos al tema Kafka configurado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:"
msgstr "En lugar de devolver una carga útil, puede devolver un `io.smallrye.reactive.messaging.kafka.Record` para enviar pares clave/valor:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "La carga útil se puede envolver dentro de `org.eclipse.microprofile.reactive.messaging.Message` para tener más control sobre los registros escritos:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.\n"
"One use case is to dynamically select the destination topic of a message.\n"
"In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic."
msgstr "`OutgoingKafkaRecordMetadata` permite establecer atributos de metadatos del registro Kafka, como `key` , `topic` , `partition` o `timestamp` . Un caso de uso es seleccionar dinámicamente el tema de destino de un mensaje. En este caso, en lugar de configurar el tema dentro del archivo de configuración de su aplicación, deberá utilizar los metadatos salientes para establecer el nombre del tema."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.\n"
"In this case the producer will use this method as generator to create an infinite stream."
msgstr "Aparte de las firmas de métodos que devuelven un flujo reactivo `Publisher` ( siendo `Multi` una implementación de `Publisher` ), el método saliente también puede devolver un único mensaje. En este caso, el productor utilizará este método como generador para crear un flujo infinito."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Sending messages with @Emitter"
msgstr "Envío de mensajes con @Emitter"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "A veces, es necesario tener una forma imperativa de enviar mensajes."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.\n"
"In this case, you cannot use `@Outgoing` because your method has parameters."
msgstr "Por ejemplo, si necesita enviar un mensaje a un flujo al recibir una solicitud POST dentro de un punto final REST. En este caso, no puede utilizar `@Outgoing` porque su método tiene parámetros."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "Para ello, puede utilizar un `Emitter`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack."
msgstr "El envío de una carga útil devuelve un `CompletionStage`, completado cuando el mensaje es aceptado. Si la transmisión del mensaje falla, el `CompletionStage` se completa excepcionalmente con la razón del nack."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`."
msgstr "La configuración de `Emitter` se realiza de la misma manera que la otra configuración de flujo utilizada por `@Incoming` y `@Outgoing`."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Using the `Emitter` you are sending messages from your imperative code to reactive messaging.\n"
"These messages are stored in a queue until they are sent.\n"
"If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.\n"
"You can use `@OnOverflow` to configure back-pressure strategy.\n"
"It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`."
msgstr "Utilizando la página `Emitter` estará enviando mensajes desde su código imperativo a la mensajería reactiva. Estos mensajes se almacenan en una cola hasta que se envían. Si el cliente productor de Kafka no puede seguir el ritmo de los mensajes que intentan enviarse a Kafka, esta cola puede convertirse en un devorador de memoria e incluso puede quedarse sin memoria. Puede utilizar `@OnOverflow` para configurar la estrategia de contrapresión. Le permite configurar el tamaño de la cola (por defecto es 256) y la estrategia a aplicar cuando se alcance el tamaño del búfer. Las estrategias disponibles son `DROP` , `LATEST` , `FAIL` , `BUFFER` , `UNBOUNDED_BUFFER` y `NONE` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message<T>`. As with the previous examples, `Message` lets you handle the ack/nack cases differently."
msgstr "Con la API `Emitter`, también puedes encapsular la carga útil saliente dentro de `Message&amp;lt;T&amp;gt;`. Como en los ejemplos anteriores, `Message` te permite manejar los casos de ack/nack de forma diferente."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni<Void>` from the `send` method.\n"
"You can therefore use Mutiny APIs for handling downstream messages and errors."
msgstr "Si prefiere utilizar las API de flujo reactivo, puede utilizar `MutinyEmitter` que devolverá `Uni<Void>` del método `send` . Por lo tanto, puede utilizar las API de Mutiny para gestionar los mensajes y errores posteriores."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.\n"
"It will only return from the method when the event is acked or nacked by the receiver."
msgstr "También es posible bloquear el envío del evento al emisor con el método `sendAndAwait` . Sólo regresará del método cuando el receptor acepte o rechace el evento."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "Las clases `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` y `io.smallrye.reactive.messaging.annotations.OnOverflow` están ahora obsoletas y se sustituyen por:"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "El nuevo método `Emitter.send` devuelve un `CompletionStage` completado cuando el mensaje producido es reconocido."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`MutinyEmitter#send(Message msg)` method is deprecated in favor of following methods receiving `Message` for emitting:"
msgstr "`MutinyEmitter#send(Message msg)` queda obsoleto en favor de los siguientes métodos que reciben `Message` para su emisión:"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`<M extends Message<? extends T>> Uni<Void> sendMessage(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; Uni&amp;lt;Void&amp;gt; sendMessage(M msg)`"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`<M extends Message<? extends T>> void sendMessageAndAwait(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; void sendMessageAndAwait(M msg)`"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`<M extends Message<? extends T>> Cancellable sendMessageAndForget(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; Cancellable sendMessageAndForget(M msg)`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "More information on how to use `Emitter` can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/emitter/[SmallRye Reactive Messaging – Emitters and Channels]"
msgstr "Puede encontrar más información sobre cómo utilizar `Emitter` en  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging - Emitters and Channels]"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Write Acknowledgement"
msgstr "Escriba el acuse de recibo"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.\n"
"Also, it stores in-memory the records that cannot be written."
msgstr "Cuando el corredor Kafka recibe un registro, su acuse de recibo puede tardar dependiendo de la configuración. Además, almacena en memoria los registros que no pueden escribirse."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).\n"
"You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr "Por defecto, el conector espera a que Kafka acuse recibo del registro para continuar con el procesamiento (acuse de recibo del mensaje recibido). Puede desactivar esto estableciendo el atributo `waitForWriteCompletion` en `false` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Note that the `acks` attribute has a huge impact on the record acknowledgement."
msgstr "Tenga en cuenta que el atributo `acks` tiene un gran impacto en el reconocimiento del registro."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If a record cannot be written, the message is nacked."
msgstr "Si no se puede escribir un registro, el mensaje es nacked."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Backpressure"
msgstr "Contrapresión"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.\n"
"The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024."
msgstr "El conector de salida Kafka gestiona la contrapresión, controlando el número de mensajes en vuelo que esperan ser escritos en el corredor Kafka. El número de mensajes en vuelo se configura mediante el atributo `max-inflight-messages` y su valor predeterminado es 1024."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The connector only sends that amount of messages concurrently.\n"
"No other messages will be sent until at least one in-flight message gets acknowledged by the broker.\n"
"Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.\n"
"Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly."
msgstr "El conector sólo envía esa cantidad de mensajes simultáneamente. No se enviará ningún otro mensaje hasta que al menos un mensaje en vuelo reciba acuse de recibo del corredor. Entonces, el conector escribe un nuevo mensaje en Kafka cuando uno de los mensajes en vuelo del corredor obtiene acuse de recibo. Asegúrese de configurar `batch.size` y `linger.ms` de Kafka en consecuencia."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.\n"
"However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`."
msgstr "También puede eliminar el límite de mensajes en vuelo estableciendo `max-inflight-messages` en `0` . Sin embargo, tenga en cuenta que el productor Kafka puede bloquearse si el número de peticiones alcanza `max.in.flight.requests.per.connection` ."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Retrying message dispatch"
msgstr "Reintento de envío de mensajes"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.\n"
"This behavior is controlled by `retries` and `retry.backoff.ms` parameters.\n"
"In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters."
msgstr "Cuando el productor de Kafka recibe un error del servidor, si se trata de un error transitorio y recuperable, el cliente volverá a intentar enviar el lote de mensajes. Este comportamiento se controla mediante los parámetros `retries` y `retry.backoff.ms` . Además, SmallRye Reactive Messaging reintentará el envío de mensajes individuales en caso de errores recuperables, en función de los parámetros `retries` y `delivery.timeout.ms` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.\n"
"If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer."
msgstr "Tenga en cuenta que aunque tener reintentos en un sistema fiable es una buena práctica, el parámetro `max.in.flight.requests.per.connection` por defecto es `5` , lo que significa que el orden de los mensajes no está garantizado. Si el orden de los mensajes es imprescindible para su caso de uso, estableciendo `max.in.flight.requests.per.connection` en `1` se asegurará de que se envía un único lote de mensajes a la vez, a costa de limitar el rendimiento del productor."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For applying retry mechanism on processing errors, see the section on <<retrying-processing>>."
msgstr "Para aplicar el mecanismo de reintento en los errores de procesamiento, consulte la sección <<retrying-processing>> ."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Handling Serialization Failures"
msgstr "Gestión de los fallos de serialización"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.\n"
"To achieve this, you need to create a bean implementing `SerializationFailureHandler<T>` interface:"
msgstr "Para el cliente productor de Kafka los fallos de serialización no son recuperables, por lo que no se vuelve a intentar el envío del mensaje. En estos casos puede que necesite aplicar una estrategia de fallo para el serializador. Para ello, debe crear un bean que implemente la interfaz `SerializationFailureHandler<T>` :"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (for key or value serializers)."
msgstr "Para utilizar este gestor de fallos, el bean debe estar expuesto con el calificador `@Identifier` y la configuración del conector debe especificar el atributo `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (para serializadores de claves o valores)."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The handler is called with details of the serialization, including the action represented as `Uni<byte[]>`.\n"
"Note that the method must await on the result and return the serialized byte array."
msgstr "Se llama al manejador con los detalles de la serialización, incluida la acción representada como `Uni<byte[]>` . Tenga en cuenta que el método debe esperar el resultado y devolver la matriz de bytes serializada."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "In-memory channels"
msgstr "Canales en memoria"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.\n"
"When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.\n"
"Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "En algunos casos de uso, es conveniente utilizar los patrones de mensajería para transferir mensajes dentro de la misma aplicación. Cuando no se conecta un canal a un backend de mensajería como Kafka, todo sucede en memoria, y los flujos se crean encadenando métodos. Cada cadena sigue siendo un flujo reactivo y aplica el protocolo de contrapresión."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The framework verifies that the producer/consumer chain is complete,\n"
"meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`),\n"
"it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "El marco de trabajo verifica que la cadena productor/consumidor esté completa, lo que significa que si la aplicación escribe mensajes en un canal en memoria (utilizando un método con sólo `@Outgoing` , o un `Emitter` ), también debe consumir los mensajes desde dentro de la aplicación (utilizando un método con sólo `@Incoming` o utilizando un flujo no gestionado)."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Broadcasting messages on multiple consumers"
msgstr "Difusión de mensajes en múltiples consumidores"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.\n"
"At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.\n"
"You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel."
msgstr "Por defecto, un canal puede estar vinculado a un único consumidor, utilizando el método `@Incoming` o el flujo reactivo `@Channel` . Al iniciarse la aplicación, se verifica que los canales formen una cadena de consumidores y productores con un único consumidor y productor. Puede anular este comportamiento configurando `mp.messaging.$channel.broadcast=true` en un canal."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,"
msgstr "En el caso de los canales en memoria, se puede utilizar la anotación `@Broadcast` en el método `@Outgoing`. Por ejemplo,"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.\n"
"On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation."
msgstr "Recíprocamente, varios productores de un mismo canal pueden fusionarse mediante la anotación `mp.messaging.incoming.$channel.merge=true` . En los métodos `@Incoming` , puede controlar cómo se fusionan varios canales utilizando la anotación `@Merge` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Repeating the `@Outgoing` annotation on outbound or processing methods allows another way of dispatching messages to multiple outgoing channels:"
msgstr "La repetición de la anotación `@Outgoing` en los métodos de salida o procesamiento permite otra forma de enviar mensajes a múltiples canales de salida:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In the previous example generated price will be broadcast to both outbound channels.\n"
"The following example selectively sends messages to multiple outgoing channels using the `Targeted` container object,\n"
"containing key as channel name and value as message payload."
msgstr "En el ejemplo anterior, el precio generado se difundirá a ambos canales salientes. El siguiente ejemplo envía mensajes de forma selectiva a varios canales salientes utilizando el objeto contenedor `Targeted` , que contiene key como nombre del canal y value como carga útil del mensaje."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Note that <<serialization-autodetection,the auto-detection for Kafka serializers>> doesn't work for signatures using the `Targeted`."
msgstr "Tenga en cuenta que xref:serialization-autodetection[la autodetección para serializadores Kafka] no funciona para las firmas que utilizan el `Targeted` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For more details on using multiple outgoings, please refer to the http://smallrye.io/smallrye-reactive-messaging/4.10.0/concepts/outgoings/[SmallRye Reactive Messaging documentation]."
msgstr "Puede encontrar información detallada sobre el uso de la anotación `@Blocking` en  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging - Handling blocking execution]."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Kafka Transactions"
msgstr "@Transactional"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Kafka transactions enable atomic writes to multiple Kafka topics and partitions.\n"
"The Kafka connector provides `KafkaTransactions` custom emitter for writing Kafka records inside a transaction.\n"
"It can be injected as a regular emitter `@Channel`:"
msgstr "Las transacciones de Kafka permiten escrituras atómicas en múltiples temas y particiones de Kafka. El conector Kafka proporciona `KafkaTransactions` emisor personalizado para escribir registros Kafka dentro de una transacción. Puede inyectarse como un emisor normal `@Channel` :"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction."
msgstr "La función dada al método `withTransaction` recibe un `TransactionalEmitter` para producir registros, y devuelve un `Uni` que proporciona el resultado de la transacción."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the processing completes successfully, the producer is flushed and the transaction is committed."
msgstr "Si el proceso se completa con éxito, el productor se vacía y la transacción se confirma."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted."
msgstr "Si el procesamiento lanza una excepción, devuelve un fallo `Uni`, o marca la `TransactionalEmitter` para abortar, la transacción se cancela."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Kafka transactional producers require configuring `acks=all` client property, and a unique id for `transactional.id`, which implies `enable.idempotence=true`.\n"
"When Quarkus detects the use of `KafkaTransactions` for an outgoing channel it configures these properties on the channel,\n"
"providing a default value of `\"${quarkus.application.name}-${channelName}\"` for `transactional.id` property."
msgstr "Los productores transaccionales Kafka requieren configurar la propiedad de cliente `acks=all` , y un id único para `transactional.id` , lo que implica `enable.idempotence=true` . Cuando Quarkus detecta el uso de `KafkaTransactions` para un canal saliente configura estas propiedades en el canal, proporcionando un valor por defecto de `\"${quarkus.application.name}-${channelName}\"` para la propiedad `transactional.id` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Note that for production use the `transactional.id` must be unique across all application instances."
msgstr "Tenga en cuenta que para el uso en producción el `transactional.id` debe ser único en todas las instancias de la aplicación."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"While a normal message emitter would support concurrent calls to `send` methods and consequently queues outgoing messages to be written to Kafka,\n"
"a `KafkaTransactions` emitter only supports one transaction at a time.\n"
"A transaction is considered in progress from the call to the `withTransaction` until the returned `Uni` results in success or failure.\n"
"While a transaction is in progress, subsequent calls to the `withTransaction`, including nested ones inside the given function, will throw `IllegalStateException`."
msgstr "Mientras que un emisor de mensajes normal soportaría llamadas concurrentes a los métodos de `send` y, en consecuencia, pondría en cola los mensajes salientes para escribirlos en Kafka, un emisor de `KafkaTransactions` sólo soporta una transacción a la vez. Se considera que una transacción está en curso desde la llamada al `withTransaction` hasta que el `Uni` devuelto resulta exitoso o fallido. Mientras una transacción esté en curso, las llamadas posteriores al `withTransaction` , incluidas las anidadas dentro de la función dada, lanzarán `IllegalStateException` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that in Reactive Messaging, the execution of processing methods, is already serialized, unless `@Blocking(ordered = false)` is used.\n"
"If `withTransaction` can be called concurrently, for example from a REST endpoint, it is recommended to limit the concurrency of the execution.\n"
"This can be done using the `@Bulkhead` annotation from xref:smallrye-fault-tolerance.adoc[_Microprofile Fault Tolerance_]."
msgstr "Tenga en cuenta que en Mensajería Reactiva, la ejecución de los métodos de procesamiento, ya está serializada, a menos que se utilice `@Blocking(ordered = false)` . Si `withTransaction` puede ser llamado concurrentemente, por ejemplo desde un punto final REST, se recomienda limitar la concurrencia de la ejecución. Esto puede hacerse utilizando la anotación `@Bulkhead` de xref:smallrye-fault-tolerance.adoc[Microprofile Fault Tolerance] ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "An example usage can be found in <<chaining-kafka-transactions-with-hibernate-reactive-transactions>>."
msgstr "Encontrará un ejemplo de uso en <<chaining-kafka-transactions-with-hibernate-reactive-transactions>> ."

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Transaction-aware consumers"
msgstr "Consumidores conscientes de las transacciones"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you'd like to consume records only written and committed inside a Kafka transaction you need to configure the `isolation.level` property on the incoming channel as such:"
msgstr "Si desea consumir registros sólo escritos y consignados dentro de una transacción Kafka, debe configurar la propiedad `isolation.level` en el canal de entrada como tal:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Kafka Request-Reply"
msgstr "Solicitud-Respuesta Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The Kafka Request-Reply pattern allows to publish a request record to a Kafka topic and then await for a reply record that responds to the initial request.\n"
"The Kafka connector provides the `KafkaRequestReply` custom emitter that implements the requestor (or the client) of the request-reply pattern for Kafka outbound channels:"
msgstr "El patrón solicitud-respuesta de Kafka permite publicar un registro de solicitud en un tema de Kafka y, a continuación, esperar un registro de respuesta que responda a la solicitud inicial. El conector Kafka proporciona el emisor personalizado `KafkaRequestReply` que implementa el solicitante (o el cliente) del patrón solicitud-respuesta para los canales salientes de Kafka:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "It can be injected as a regular emitter `@Channel`:"
msgstr "Puede inyectarse como un emisor normal `@Channel` :"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The request method publishes the record to the configured target topic of the outgoing channel,\n"
"and polls a reply topic (by default, the target topic with `-replies` suffix) for a reply record.\n"
"When the reply is received the returned `Uni` is completed with the record value.\n"
"The request send operation generates a **correlation id** and sets a header (by default `REPLY_CORRELATION_ID`),\n"
"which it expects to be sent back in the reply record."
msgstr "El método de solicitud publica el registro en el tema de destino configurado del canal saliente, y sondea un tema de respuesta (por defecto, el tema de destino con sufijo `-replies` ) en busca de un registro de respuesta. Cuando se recibe la respuesta, el `Uni` devuelto se completa con el valor del registro. La operación de envío de la solicitud genera un *id de correlación* y establece una cabecera (por defecto `REPLY_CORRELATION_ID` ), que espera que se devuelva en el registro de respuesta."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The replier can be implemented using a Reactive Messaging processor (see <<processing-messages>>)."
msgstr "El replicador puede implementarse utilizando un procesador de mensajería reactiva (véase <<processing-messages>> )."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"For more information on Kafka Request Reply feature and advanced configuration options,\n"
"see the https://smallrye.io/smallrye-reactive-messaging/latest/kafka/request-reply/[Smallrye Reactive Messaging Documentation]."
msgstr "Para obtener más información sobre la función de respuesta a solicitudes de Kafka y las opciones de configuración avanzadas, consulte la link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/request-reply/[documentación sobre mensajería reactiva de Smallrye] ."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Processing Messages"
msgstr "Procesamiento de mensajes"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.\n"
"A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:"
msgstr "Las aplicaciones que transmiten datos a menudo necesitan consumir algunos eventos de un tema, procesarlos y publicar el resultado en un tema diferente. Un método procesador puede implementarse de forma sencilla utilizando las anotaciones `@Incoming` y `@Outgoing` :"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.\n"
"Previously mentioned signatures for parameter and return types are also supported, such as `Message<T>`, `Record<K, V>`, etc."
msgstr "El parámetro del método `process` es la carga útil del mensaje entrante, mientras que el valor de retorno se utilizará como carga útil del mensaje saliente. También se admiten las firmas mencionadas anteriormente para los tipos de parámetro y de retorno, como `Message<T>` , `Record<K, V>` , etc."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can apply asynchronous stream processing by consuming and returning reactive stream `Multi<T>` type:"
msgstr "Puede aplicar el procesamiento asíncrono de flujos consumiendo y devolviendo flujos reactivos del tipo `Multi&amp;lt;T&amp;gt;`:"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Propagating Record Key"
msgstr "Propagación de la clave de registro"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When processing messages, you can propagate incoming record key to the outgoing record."
msgstr "Al procesar los mensajes, puede propagar la clave del registro de entrada al registro de salida."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration,\n"
"record key propagation produces the outgoing record with the same _key_ as the incoming record."
msgstr "Activada con la configuración `mp.messaging.outgoing.$channel.propagate-record-key=true` , la propagación de la clave del registro produce el registro saliente con la misma _clave_ que el registro entrante."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.\n"
"If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used."
msgstr "Si el registro saliente ya contiene una _clave_ , ésta *no será anulada* por la clave del registro entrante. Si el registro entrante sí tiene una clave _nula_ , se utilizará la propiedad `mp.messaging.outgoing.$channel.key` ."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Exactly-Once Processing"
msgstr "Reintento de procesamiento"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Kafka Transactions allows managing consumer offsets inside a transaction, together with produced messages.\n"
"This enables coupling a consumer with a transactional producer in a _consume-transform-produce_ pattern, also known as *exactly-once processing*."
msgstr "Kafka Transactions permite gestionar los desplazamientos del consumidor dentro de una transacción, junto con los mensajes producidos. Esto permite acoplar un consumidor con un productor transaccional en un patrón _consumir-transformar-producir_ , también conocido como *procesamiento exactamente una vez* ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The `KafkaTransactions` custom emitter provides a way to apply exactly-once processing to an incoming Kafka message inside a transaction."
msgstr "El emisor personalizado `KafkaTransactions` proporciona una forma de aplicar un procesamiento exactamente único a un mensaje Kafka entrante dentro de una transacción."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The following example includes a batch of Kafka records inside a transaction."
msgstr "El siguiente ejemplo incluye un lote de registros Kafka dentro de una transacción."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"It is recommended to use exactly-once processing along with the batch consumption mode.\n"
"While it is possible to use it with a single Kafka message, it'll have a significant performance impact."
msgstr "Se recomienda utilizar el procesamiento exactamente una vez junto con el modo de consumo por lotes. Aunque es posible utilizarlo con un único mensaje Kafka, tendrá un impacto significativo en el rendimiento."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The consumed `KafkaRecordBatch` message is passed to the `KafkaTransactions#withTransactionAndAck` in order to handle the offset commits and message acks."
msgstr "El mensaje consumido de `KafkaRecordBatch` se pasa a `KafkaTransactions#withTransactionAndAck` para manejar los commits y los acks de los mensajes."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `send` method writes records to Kafka inside the transaction, without waiting for send receipt from the broker.\n"
"Messages pending to be written to Kafka will be buffered, and flushed before committing the transaction.\n"
"It is therefore recommended configuring the `@OnOverflow` `bufferSize` in order to fit enough messages, for example the `max.poll.records`, maximum amount of records returned in a batch."
msgstr "El método `send` escribe registros en Kafka dentro de la transacción, sin esperar a la recepción del envío por parte del intermediario. Los mensajes pendientes de escribirse en Kafka se almacenarán en el búfer y se vaciarán antes de consignar la transacción. Por lo tanto, se recomienda configurar `@OnOverflow` `bufferSize` con el fin de que quepan suficientes mensajes, por ejemplo `max.poll.records` , cantidad máxima de registros devueltos en un lote."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the processing completes successfully, _before committing the transaction_, the topic partition offsets of the given batch message will be committed to the transaction."
msgstr "Si el procesamiento se completa con éxito, _antes de consignar la_ transacción, los offsets de partición de temas del mensaje de lote dado se consignarán en la transacción."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the processing needs to abort, _after aborting the transaction_, the consumer's position is reset to the last committed offset, effectively resuming the consumption from that offset. If no consumer offset has been committed to a topic-partition, the consumer's position is reset to the beginning of the topic-partition, _even if the offset reset policy is `latest`_."
msgstr "Si el procesamiento necesita ser abortado, _después de abortar la transacción_, la posición del consumidor se restablece al último offset comprometido, reanudando efectivamente el consumo desde ese offset. Si no se ha comprometido ningún desplazamiento del consumidor en una partición de temas, la posición del consumidor se restablece al principio de la partición de temas, _incluso si la política de restablecimiento del desplazamiento es `última`_."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When using exactly-once processing, consumed message offset commits are handled by the transaction and therefore the application should not commit offsets through other means.\n"
"The consumer should have `enable.auto.commit=false` (the default) and set explicitly `commit-strategy=ignore`:"
msgstr "Cuando se utiliza el procesamiento \"exactamente una vez\", las confirmaciones de desplazamiento de mensajes consumidos son gestionadas por la transacción y, por lo tanto, la aplicación no debe confirmar los desplazamientos por otros medios. El consumidor debe tener `enable.auto.commit=false` (el valor predeterminado) y establecer explícitamente `commit-strategy=ignore` :"

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Error handling for the exactly-once processing"
msgstr "Tratamiento de errores para el procesamiento de exactamente una vez"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `Uni` returned from the `KafkaTransactions#withTransaction` will yield a failure if the transaction fails and is aborted.\n"
"The application can choose to handle the error case, but if a failing `Uni` is returned from the `@Incoming` method, the incoming channel will effectively fail and stop the reactive stream."
msgstr "El `Uni` devuelto desde el `KafkaTransactions#withTransaction` producirá un fallo si la transacción falla y es abortada. La aplicación puede elegir manejar el caso de error, pero si se devuelve un `Uni` fallido desde el método `@Incoming` , el canal entrante fallará efectivamente y detendrá el flujo reactivo."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `KafkaTransactions#withTransactionAndAck` method acks and nacks the message but will *not* return a failing `Uni`.\n"
"Nacked messages will be handled by the failure strategy of the incoming channel, (see <<error-handling>>).\n"
"Configuring `failure-strategy=ignore` simply resets the Kafka consumer to the last committed offsets and resumes the consumption from there."
msgstr "El método `KafkaTransactions#withTransactionAndAck` acks y nacks el mensaje pero *no* devolverá un fallo `Uni` . Los mensajes nacked serán manejados por la estrategia de fallo del canal entrante, (ver <<error-handling>> ). Configurar `failure-strategy=ignore` simplemente restablece el consumidor Kafka a los últimos desplazamientos comprometidos y reanuda el consumo a partir de ahí."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Accessing Kafka clients directly"
msgstr "Acceso directo a los clientes de Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In rare cases, you may need to access the underlying Kafka clients.\n"
"`KafkaClientService` provides thread-safe access to `Producer` and `Consumer`."
msgstr "En casos excepcionales, puede que necesite acceder a los clientes Kafka subyacentes. `KafkaClientService` proporciona un acceso a prueba de hilos a `Producer` y `Consumer` ."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The `KafkaClientService` is an experimental API and can change in the future."
msgstr "La `KafkaClientService` es una API experimental y puede cambiar en el futuro."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:"
msgstr "También puede obtener la configuración de Kafka inyectada en su aplicación y crear clientes productores, consumidores y administradores de Kafka directamente:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.\n"
"For more configuration options check out <<kafka-configuration-resolution>>."
msgstr "El mapa de configuración `default-kafka-broker` contiene todas las propiedades de la aplicación prefijadas con `kafka.` o `KAFKA_` . Para más opciones de configuración consulte <<kafka-configuration-resolution>> ."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "JSON serialization"
msgstr "Serialización JSON"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkus tiene capacidades incorporadas para tratar con mensajes JSON Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Imagine we have a `Fruit` data class as follows:"
msgstr "Imaginemos que tenemos una clase de datos `Fruit` como la siguiente:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "Y queremos usarlo para recibir mensajes de Kafka, hacer alguna transformación de precios, y enviar mensajes de vuelta a Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To do this, we will need to set up JSON serialization with Jackson or JSON-B."
msgstr "Para ello, necesitaremos configurar la serialización JSON con Jackson o JSON-B."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "Con la serialización JSON correctamente configurada, también se puede utilizar `Publisher&amp;lt;Fruit&amp;gt;` y `Emitter&amp;lt;Fruit&amp;gt;`."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Serializing via Jackson"
msgstr "Serialización a través de Jackson"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus has built-in support for JSON serialization and deserialization based on Jackson.\n"
"It will also <<serialization-generation,generate>> the serializer and deserializer for you, so you do not have to configure anything.\n"
"When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below."
msgstr "Quarkus tiene soporte incorporado para la serialización y deserialización de JSON basado en Jackson. También xref:serialization-generation[generará] el serializador y deserializador por usted, por lo que no tendrá que configurar nada. Cuando la generación está desactivada, puede utilizar los proporcionados `ObjectMapperSerializer` y `ObjectMapperDeserializer` como se explica a continuación."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.\n"
"You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr "Existe un `ObjectMapperSerializer` que puede utilizarse para serializar todos los objetos de datos a través de Jackson. Puede crear una subclase vacía si desea utilizar <<serialization-autodetection>> ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"By default, the `ObjectMapperSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration\n"
"property `json.serialize.null-as-null=true` which will serialize null as `null`.\n"
"This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "Por defecto, `ObjectMapperSerializer` serializa null como la cadena `\"null\"` , esto puede personalizarse estableciendo la propiedad de configuración de Kafka `json.serialize.null-as-null=true` que serializará null como `null` . Esto resulta útil cuando se utiliza un tema compactado, ya que `null` se utiliza como lápida para saber qué mensajes se eliminan durante la fase de compactación."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The corresponding deserializer class needs to be subclassed.\n"
"So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr "Es necesario subclasificar la clase deserializadora correspondiente. Así pues, creemos un `FruitDeserializer` que extienda el `ObjectMapperDeserializer` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Finally, configure your channels to use the Jackson serializer and deserializer."
msgstr "Por último, configure sus canales para utilizar el serializador y el deserializador de Jackson."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.\n"
"In this case, the `deserializer` configuration is not necessary as the <<serialization-autodetection>> is enabled by default."
msgstr "Ahora, sus mensajes Kafka contendrán una representación serializada Jackson de su objeto de datos `Fruit` . En este caso, la configuración de `deserializer` no es necesaria, ya que <<serialization-autodetection>> está activada por defecto."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a Jackson `TypeReference` denoted the generic collection used."
msgstr "Si quieres deserializar una lista de frutas, necesitas crear un deserializador con un Jackson `TypeReference` que denote la colección genérica utilizada."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Serializing via JSON-B"
msgstr "Serialización mediante JSON-B"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "First, you need to include the `quarkus-jsonb` extension."
msgstr "En primer lugar, debe incluir la extensión `quarkus-jsonb`."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.\n"
"You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr "Existe un `JsonbSerializer` que puede utilizarse para serializar todos los objetos de datos mediante JSON-B. Puede crear una subclase vacía si desea utilizar <<serialization-autodetection>> ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"By default, the `JsonbSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration\n"
"property `json.serialize.null-as-null=true` which will serialize null as `null`.\n"
"This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "Por defecto, `JsonbSerializer` serializa null como la cadena `\"null\"` , esto puede personalizarse estableciendo la propiedad de configuración de Kafka `json.serialize.null-as-null=true` que serializará null como `null` . Esto resulta útil cuando se utiliza un tema compactado, ya que `null` se utiliza como lápida para saber qué mensajes se eliminan durante la fase de compactación."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The corresponding deserializer class needs to be subclassed.\n"
"So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr "Es necesario subclasificar la clase deserializadora correspondiente. Así pues, creemos un `FruitDeserializer` que extienda el genérico `JsonbDeserializer` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Finally, configure your channels to use the JSON-B serializer and deserializer."
msgstr "Por último, configura tus canales para que utilicen el serializador y deserializador JSON-B."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object."
msgstr "Ahora, sus mensajes Kafka contarán con una representación serializada JSON-B de su objeto de datos `Fruit`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a `Type` denoted the generic collection used."
msgstr "Si quieres deserializar una lista de frutas, necesitas crear un deserializador con un `Type` que denote la colección genérica utilizada."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n"
"that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr "Si no desea crear un deserializador para cada objeto de datos, puede utilizar el genérico `io.vertx.kafka.client.serialization.JsonObjectDeserializer` que deserializará a un `io.vertx.core.json.JsonObject` . También se puede utilizar el serializador correspondiente: `io.vertx.kafka.client.serialization.JsonObjectSerializer` ."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Avro Serialization"
msgstr "Serialización Avro"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro]."
msgstr "Esto se describe en una guía dedicada:  link:kafka-schema-registry-avro.html[Uso de Apache Kafka con Schema Registry y Avro]."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "JSON Schema Serialization"
msgstr "Serialización del esquema JSON"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-schema-registry-json-schema.adoc[Using Apache Kafka with Schema Registry and JSON Schema]."
msgstr "Esto se describe en una guía dedicada: xref:kafka-schema-registry-json-schema.adoc[Uso de Apache Kafka con Schema Registry y JSON Schema] ."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Serializer/deserializer autodetection"
msgstr "Autodetección del serializador/deserializador"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.\n"
"This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr "Cuando se utiliza SmallRye Reactive Messaging con Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka` ), Quarkus puede a menudo detectar automáticamente la clase correcta de serializador y deserializador. Esta autodetección se basa en las declaraciones de los métodos `@Incoming` y `@Outgoing` , así como en los inyectados `@Channel` s."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For example, if you declare"
msgstr "Por ejemplo, si declara"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`."
msgstr "y su configuración indica que el canal `generated-price` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `value.serializer` con el `IntegerSerializer` incorporado de Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Similarly, if you declare"
msgstr "Del mismo modo, si se declara"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`."
msgstr "y su configuración indica que el canal `my-kafka-records` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `key.deserializer` al `LongDeserializer` incorporado de Kafka, así como el `value.deserializer` a `ByteArrayDeserializer`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Finally, if you declare"
msgstr "Por último, si declara"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`."
msgstr "y su configuración indica que el canal `price-create` utiliza el conector `smallrye-kafka`, entonces Quarkus configurará automáticamente el `value.serializer` con el `DoubleSerializer` incorporado de Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The full set of types supported by the serializer/deserializer autodetection is:"
msgstr "El conjunto completo de tipos soportados por la autodetección del serializador/deserializador es:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`short` and `java.lang.Short`"
msgstr "`short` y `java.lang.Short`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`int` and `java.lang.Integer`"
msgstr "`int` y `java.lang.Integer`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`long` and `java.lang.Long`"
msgstr "`long` y `java.lang.Long`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`float` and `java.lang.Float`"
msgstr "`float` y `java.lang.Float`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`double` and `java.lang.Double`"
msgstr "`double` y `java.lang.Double`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
msgid "`byte[]`"
msgstr "`byte[]`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`java.lang.String`"
msgstr "`java.lang.String`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`java.util.UUID`"
msgstr "`java.util.UUID`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.apache.kafka.common.utils.Bytes`"
msgstr "`org.apache.kafka.common.utils.Bytes`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`io.vertx.core.buffer.Buffer`"
msgstr "`io.vertx.core.buffer.Buffer`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`io.vertx.core.json.JsonObject`"
msgstr "`io.vertx.core.json.JsonObject`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`io.vertx.core.json.JsonArray`"
msgstr "`io.vertx.core.json.JsonArray`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "classes for which a direct implementation of `org.apache.kafka.common.serialization.Serializer<T>` / `org.apache.kafka.common.serialization.Deserializer<T>` is present."
msgstr "clases para las que existe una implementación directa de `org.apache.kafka.common.serialization.Serializer&amp;lt;T&amp;gt;` / `org.apache.kafka.common.serialization.Deserializer&amp;lt;T&amp;gt;`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "the implementation needs to specify the type argument `T` as the (de-)serialized type."
msgstr "la implementación necesita especificar el argumento de tipo `T` como el tipo (des)serializado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, if Confluent or Apicurio Registry _serde_ is present"
msgstr "clases generadas a partir de esquemas Avro, así como Avro `GenericRecord`, si Confluent o Apicurio Registry _serde_ está presente"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "in case multiple Avro serdes are present, serializer/deserializer must be configured manually for Avro-generated classes, because autodetection is impossible"
msgstr "en caso de que haya varios serdes Avro, el serializador/deserializador debe configurarse manualmente para las clases generadas por Avro, ya que la autodetección es imposible"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "see xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio Registry libraries"
msgstr "Para más información sobre el uso de las librerías Confluent o Apicurio Registry, consulte  link:kafka-schema-registry-avro.html[Uso de Apache Kafka con Schema Registry y Avro]"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in <<jackson-serialization>>"
msgstr "clases para las que existe una subclase de `ObjectMapperSerializer` / `ObjectMapperDeserializer` , como se describe en <<jackson-serialization>>"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible"
msgstr "técnicamente no es necesario subclasificar `ObjectMapperSerializer`, pero en tal caso, la autodetección no es posible"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in <<jsonb-serialization>>"
msgstr "clases para las que existe una subclase de `JsonbSerializer` / `JsonbDeserializer` , como se describe en <<jsonb-serialization>>"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible"
msgstr "técnicamente no es necesario subclasificar `JsonbSerializer`, pero en tal caso, la autodetección no es posible"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection."
msgstr "Si se establece un serializador/deserializador por configuración, no será reemplazado por la autodetección."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.\n"
"If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr "En caso de que tenga algún problema con la autodetección del serializador, puede desactivarla completamente configurando `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false` . Si encuentra que necesita hacer esto, por favor archive un error en el link:https://github.com/quarkusio/quarkus/issues[rastreador de problemas de Quarkus] para que podamos solucionar el problema que tenga."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "JSON Serializer/deserializer generation"
msgstr "Generación de serializadores/deserializadores JSON"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Quarkus automatically generates serializers and deserializers for channels where:"
msgstr "Quarkus genera automáticamente serializadores y deserializadores para los canales donde:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "the serializer/deserializer is not configured"
msgstr "el serializador/deserializador no está configurado"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "the auto-detection did not find a matching serializer/deserializer"
msgstr "la autodetección no encontró un serializador/deserializador coincidente"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "It uses Jackson underneath."
msgstr "Utiliza a Jackson por debajo."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This generation can be disabled using:"
msgstr "Esta generación se puede desactivar mediante:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Generation does not support collections such as `List<Fruit>`.\n"
"Refer to <<jackson-serialization>> to write your own serializer/deserializer for this case."
msgstr "La generación no admite colecciones como `List<Fruit>` . Consulte <<jackson-serialization>> para escribir su propio serializador/deserializador para este caso."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Using Schema Registry"
msgstr "Uso del registro de esquemas"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This is described in a dedicated guide for Avro: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro].\n"
"And a different one for JSON Schema: xref:kafka-schema-registry-json-schema.adoc[Using Apache Kafka with Schema Registry and JSON Schema]."
msgstr "Esto se describe en una guía dedicada para Avro: xref:kafka-schema-registry-avro.adoc[Uso de Apache Kafka con Schema Registry y] Avro. Y otra diferente para JSON Schema: Uso de Apache Kafka con Schema Registry y JSON xref:kafka-schema-registry-json-schema.adoc[Schema] ."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Health Checks"
msgstr "Controles de salud"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus provides several health checks for Kafka.\n"
"These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr "Quarkus proporciona varias comprobaciones de salud para Kafka. Estas comprobaciones se utilizan en combinación con la extensión `quarkus-smallrye-health` ."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Kafka Broker Readiness Check"
msgstr "Comprobación de la disponibilidad del corredor Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n"
"This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).\n"
"It requires an _admin connection_ with the Kafka broker, and it is disabled by default.\n"
"If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr "Si utiliza la extensión `quarkus-kafka-client` , puede habilitar la comprobación del estado de _disponibilidad_ estableciendo la propiedad `quarkus.kafka.health.enabled` en `true` en su `application.properties` . Esta comprobación informa del estado de la interacción con un corredor Kafka _predeterminado_ (configurado mediante `kafka.bootstrap.servers` ). Requiere una _conexión de administrador_ con el corredor Kafka y está desactivada por defecto. Si está habilitada, cuando acceda al endpoint `/q/health/ready` de su aplicación, dispondrá de información sobre el estado de validación de la conexión."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Kafka Reactive Messaging Health Checks"
msgstr "Comprobaciones de salud de la mensajería reactiva de Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks."
msgstr "Cuando se utiliza la Mensajería Reactiva y el conector Kafka, cada canal configurado (entrante o saliente) proporciona comprobaciones de _inicio_, _capacidad_ y _disponibilidad_."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The _startup_ check verifies that the communication with Kafka cluster is established."
msgstr "La comprobación de _inicio_ verifica que se ha establecido la comunicación con el clúster Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka."
msgstr "La comprobación _de la vitalidad_ captura cualquier fallo irrecuperable que se produzca durante la comunicación con Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics."
msgstr "La comprobación _de disponibilidad_ verifica que el conector Kafka está listo para consumir/producir mensajes a los temas Kafka configurados."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For each channel, you can disable the checks using:"
msgstr "Para cada canal, puede desactivar las comprobaciones mediante:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.\n"
"Default is `kafka.bootstrap.servers`."
msgstr "Puede configurar el `bootstrap.servers` para cada canal utilizando la propiedad `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` . Por defecto es `kafka.bootstrap.servers` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Reactive Messaging _startup_ and _readiness_ checks offer two strategies.\n"
"The default strategy verifies that an active connection is established with the broker.\n"
"This approach is not intrusive as it's based on built-in Kafka client metrics."
msgstr "Las comprobaciones de _inicio_ y _preparación de_ la mensajería reactiva ofrecen dos estrategias. La estrategia por defecto verifica que se establece una conexión activa con el broker. Este enfoque no es intrusivo, ya que se basa en las métricas incorporadas del cliente Kafka."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.\n"
"Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption,\n"
"and for an outgoing channel checks that the topic used by the producer exist in the broker."
msgstr "Utilizando el atributo `health-topic-verification-enabled=true` , la sonda de puesta en _marcha_ utiliza un _cliente admin_ para comprobar la lista de temas. Mientras que la sonda de _preparación_ para un canal entrante comprueba que al menos una partición está asignada para el consumo, y para un canal saliente comprueba que el tema utilizado por el productor existe en el corredor."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that to achieve this, an _admin connection_ is required.\n"
"You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration."
msgstr "Tenga en cuenta que para ello se necesita una _conexión de administrador_ . Puede ajustar el tiempo de espera de las llamadas de verificación de temas al agente mediante la configuración de `health-topic-verification-timeout` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Observability"
msgstr "Observabilidad"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If the xref:opentelemetry.adoc[OpenTelemetry extension] is present,\n"
"then the Kafka connector channels work out-of-the-box with the OpenTelemetry Tracing.\n"
"Messages written to Kafka topics propagate the current tracing span.\n"
"On incoming channels, if a consumed Kafka record contains tracing information the message processing inherits the message span as parent."
msgstr "Si la xref:opentelemetry.adoc[extensión OpenTelemetry] está presente, entonces los canales del conector Kafka funcionan \"out-of-the-box\" con el rastreo OpenTelemetry. Los mensajes escritos en temas Kafka propagan el tramo de rastreo actual. En los canales entrantes, si un registro Kafka consumido contiene información de rastreo, el procesamiento del mensaje hereda el tramo del mensaje como padre."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Tracing can be disabled explicitly per channel:"
msgstr "El rastreo puede desactivarse explícitamente por canal:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If the xref:telemetry-micrometer.adoc[Micrometer extension] is present,\n"
"then Kafka producer and consumer clients metrics are exposed as Micrometer meters."
msgstr "Si la xref:telemetry-micrometer.adoc[extensión Micrometer] está presente, las métricas de los clientes productores y consumidores de Kafka se exponen como contadores Micrometer."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Per channel metrics are also exposed as Micrometer meters.\n"
"The number of messages produced or received per channel, acknowledgments and duration of processing are exposed."
msgstr "Las métricas por canal también se exponen como micromedidores. Se exponen el número de mensajes producidos o recibidos por canal, los acuses de recibo y la duración del procesamiento."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The messaging meters can be disabled:"
msgstr "Los contadores de mensajes pueden desactivarse:"

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Kafka Streams"
msgstr "Kafka Streams"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-streams.adoc[Using Apache Kafka Streams]."
msgstr "Esto se describe en una guía dedicada:  link:kafka-streams.html[Uso de Apache Kafka Streams]."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Using Snappy for message compression"
msgstr "Uso de Snappy para la compresión de mensajes"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr "En los canales de _salida_, puedes activar la compresión Snappy configurando el atributo `compression.type` como `snappy`:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In JVM mode, it will work out of the box.\n"
"However, to compile your application to a native executable, you need to\n"
"add `quarkus.kafka.snappy.enabled=true` to your `application.properties`."
msgstr "En modo JVM, funcionará de forma inmediata. Sin embargo, para compilar su aplicación a un ejecutable nativo, necesita añadir `quarkus.kafka.snappy.enabled=true` a su `application.properties` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr "En el modo nativo, Snappy está desactivado por defecto, ya que el uso de Snappy requiere incrustar una biblioteca nativa y desempaquetarla cuando se inicia la aplicación."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Authentication with OAuth"
msgstr "Autenticación con OAuth"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.\n"
"First, add the following dependency to your application:"
msgstr "Si su corredor Kafka utiliza OAuth como mecanismo de autenticación, deberá configurar el consumidor Kafka para habilitar este proceso de autenticación. En primer lugar, añada la siguiente dependencia a su aplicación:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This dependency provides the callback handler required to handle the OAuth workflow.\n"
"Then, in the `application.properties`, add:"
msgstr "Esta dependencia proporciona el controlador de devolución de llamada necesario para manejar el flujo de trabajo OAuth. A continuación, en el `application.properties` , añada:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "Actualice los valores de `oauth.client.id`, `oauth.client.secret` y `oauth.token.endpoint.uri`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)"
msgstr "La autenticación OAuth funciona tanto en el modo JVM como en el nativo. Dado que SSL no está habilitado por defecto en el modo nativo, se debe añadir `quarkus.ssl.native=true` para soportar JaasClientOauthLoginCallbackHandler, que utiliza SSL. (Para más detalles, consulte la guía  link:native-and-ssl.html[Using SSL with Native Executables] )."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Testing a Kafka application"
msgstr "Probar una aplicación Kafka"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Testing without a broker"
msgstr "Pruebas sin intermediario"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"It can be useful to test the application without having to start a Kafka broker.\n"
"To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "Puede ser útil para probar la aplicación sin tener que iniciar un corredor Kafka. Para conseguirlo, puede _cambiar_ los canales gestionados por el conector Kafka a _in-memory_ ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "Este enfoque sólo funciona para las pruebas de la JVM. No se puede utilizar para las pruebas nativas (porque no soportan la inyección)."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Let's say we want to test the following processor application:"
msgstr "Digamos que queremos probar la siguiente aplicación del procesador:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "First, add the following test dependency to your application:"
msgstr "En primer lugar, añada la siguiente dependencia de prueba a su aplicación:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "A continuación, cree un recurso de prueba de Quarkus de la siguiente manera:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Switch the incoming channel `orders` (expecting messages from Kafka) to in-memory."
msgstr "Cambia el canal de entrada `orders` (que espera mensajes de Kafka) por uno en memoria."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Switch the outgoing channel `beverages` (writing messages to Kafka) to in-memory."
msgstr "Cambiar el canal de salida `beverages` (escribir mensajes a Kafka) a in-memory."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "Construye y devuelve un `Map` que contiene todas las propiedades necesarias para configurar la aplicación para utilizar canales en memoria."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "Cuando la prueba se detenga, borre el `InMemoryConnector` (descarte todos los mensajes recibidos y enviados)"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "Cree una prueba de Quarkus utilizando el recurso de prueba creado anteriormente:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Inject the in-memory connector in your test class."
msgstr "Inyecte el conector en memoria en su clase de prueba."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar el canal de entrada ( `orders`) - el canal debe haber sido cambiado a la memoria en el recurso de prueba."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Retrieve the outgoing channel (`beverages`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar el canal de salida ( `beverages`) - el canal debe haber sido cambiado a la memoria en el recurso de prueba."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Use the `send` method to send a message to the `orders` channel.\n"
"The application will process this message and send a message to `beverages` channel."
msgstr "Utilice el método `send` para enviar un mensaje al canal `orders` . La aplicación procesará este mensaje y enviará un mensaje al canal `beverages` ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Use the `received` method on `beverages` channel to check the messages produced by the application."
msgstr "Utilice el método `received` en el canal `beverages` para comprobar los mensajes producidos por la aplicación."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If your Kafka consumer is batch based, you will need to send a batch of messages to the channel as by creating them manually."
msgstr "Si su consumidor Kafka está basado en lotes, necesitará enviar un lote de mensajes al canal como creándolos manualmente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For instance:"
msgstr "Por ejemplo:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Create an `AtomicBoolean` to track if the batch has been committed."
msgstr "Cree un `AtomicBoolean` para saber si el lote se ha consignado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Update `committed` when the batch is committed."
msgstr "Actualizar `committed` cuando se confirma el lote."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Create a `IncomingKafkaRecordBatch` with a single record."
msgstr "Cree un `IncomingKafkaRecordBatch` con un único registro."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Wait until the batch is committed."
msgstr "Espere hasta que el lote se confirme."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"With in-memory channels we were able to test application code processing messages without starting a Kafka broker.\n"
"Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic."
msgstr "Con los canales en memoria pudimos probar el código de la aplicación procesando mensajes sin iniciar un broker de Kafka. Tenga en cuenta que los distintos canales en memoria son independientes y que cambiar el conector de canal a en memoria no simula la entrega de mensajes entre canales configurados para el mismo tema de Kafka."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Context propagation with InMemoryConnector"
msgstr "Propagación del contexto con InMemoryConnector"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "By default, in-memory channels dispatch messages on the caller thread, which would be the main thread in unit tests."
msgstr "Por defecto, los canales en memoria despachan los mensajes en el hilo de llamada, que sería el hilo principal en las pruebas unitarias."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The `quarkus-test-vertx` dependency provides the `@io.quarkus.test.vertx.RunOnVertxContext` annotation,\n"
"which when used on a test method, executes the test on a Vert.x context."
msgstr "La dependencia `quarkus-test-vertx` proporciona la anotación `@io.quarkus.test.vertx.RunOnVertxContext` , que cuando se utiliza en un método de prueba, ejecuta la prueba en un contexto Vert.x."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "However, most of the other connectors handle context propagation dispatching messages on separate duplicated Vert.x contexts."
msgstr "Sin embargo, la mayoría de los demás conectores manejan la propagación de contextos despachando mensajes en contextos Vert.x duplicados por separado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If your tests are dependent on context propagation,\n"
"you can configure the in-memory connector channels with the `run-on-vertx-context` attribute to dispatch events,\n"
"including messages and acknowledgements, on a Vert.x context.\n"
"Alternatively you can switch this behaviour using the `InMemorySource#runOnVertxContext` method."
msgstr "Si sus pruebas dependen de la propagación de contextos, puede configurar los canales del conector en memoria con el atributo `run-on-vertx-context` para que envíen eventos, incluidos mensajes y acuses de recibo, en un contexto Vert.x. También puede cambiar este comportamiento utilizando el método `InMemorySource#runOnVertxContext` ."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Testing using a Kafka broker"
msgstr "Pruebas con un broker de Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If you are using <<kafka-dev-services>>, a Kafka broker will be started and available throughout the tests, unless it is disabled in `%test` profile.\n"
"While it is possible to connect to this broker using Kafka Clients API,\n"
"https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] proposes an easier way of interacting with a Kafka broker and, creating consumer, producer and admin actions inside tests."
msgstr "Si está utilizando <<kafka-dev-services>> , un broker de Kafka se iniciará y estará disponible durante todas las pruebas, a menos que esté desactivado en el perfil de `%test` . Aunque es posible conectarse a este broker utilizando la API de clientes de Kafka, link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] propone una forma más sencilla de interactuar con un broker de Kafka y, crear acciones de consumidor, productor y administrador dentro de las pruebas."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For using `KafkaCompanion` API in tests, start by adding the following dependency:"
msgstr "Para utilizar la API `KafkaCompanion` en las pruebas, comience por añadir la siguiente dependencia:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "which provides `io.quarkus.test.kafka.KafkaCompanionResource` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "que proporciona `io.quarkus.test.kafka.KafkaCompanionResource` - una implementación de `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Then use `@QuarkusTestResource` to configure the Kafka Companion in tests, for example:"
msgstr "A continuación, utilice `@QuarkusTestResource` para configurar el Kafka Companion en las pruebas, por ejemplo:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`@InjectKafkaCompanion` injects the `KafkaCompanion` instance, configured to access the Kafka broker created for tests."
msgstr "`@InjectKafkaCompanion` inyecta la instancia `KafkaCompanion`, configurada para acceder al broker Kafka creado para las pruebas."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Use `KafkaCompanion` to create producer task which writes 10 records to 'orders' topic."
msgstr "Utilice `KafkaCompanion` para crear una tarea de producción que escriba 10 registros en el tema \"pedidos\"."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Create consumer task which subscribes to 'orders-processed' topic and consumes 10 records."
msgstr "Crear una tarea de consumo que se suscriba al tema \"pedidos procesados\" y consuma 10 registros."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Await completion of the consumer task."
msgstr "Esperar la finalización de la tarea del consumidor."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the Kafka Dev Service is available during tests, `KafkaCompanionResource` uses the created Kafka broker, otherwise it creates a Kafka broker using https://github.com/strimzi/test-container[Strimzi Test Container]."
msgstr "Si el Kafka Dev Service está disponible durante las pruebas, `KafkaCompanionResource` utiliza el broker Kafka creado, de lo contrario crea un broker Kafka utilizando  link:https://github.com/strimzi/test-container[el Strimzi Test Container]."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The configuration of the created Kafka broker can be customized using `@ResourceArg`, for example:"
msgstr "La configuración del broker Kafka creado puede personalizarse mediante `@ResourceArg`, por ejemplo:"

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Custom test resource"
msgstr "Recurso de prueba personalizado"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Alternatively, you can start a Kafka broker in a test resource.\n"
"The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "Como alternativa, puede iniciar un corredor Kafka en un recurso de prueba. El siguiente fragmento muestra un recurso de prueba que inicia un corredor Kafka utilizando link:https://www.testcontainers.org/modules/kafka/[Testcontainers] :"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "Configurar la ubicación del bootstrap de Kafka, para que la aplicación se conecte a este broker."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Kubernetes Service Bindings"
msgstr "Enlaces de servicio Kubernetes"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus Kafka extension supports\n"
"xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].\n"
"You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application."
msgstr "La extensión Kafka de Quarkus soporta la xref:deploying-to-kubernetes.adoc[Especificación de Vinculación de Servicios para Kubernetes] . Puede habilitarla añadiendo la extensión `quarkus-kubernetes-service-binding` a su aplicación."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration."
msgstr "Cuando se ejecuta en clústeres de Kubernetes debidamente configurados, la extensión de Kafka extraerá su configuración de conexión del broker de Kafka del enlace de servicio disponible dentro del clúster, sin necesidad de configuración por parte del usuario."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Execution model"
msgstr "Modelo de ejecución"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Reactive Messaging invokes user's methods on an I/O thread.\n"
"Thus, by default, the methods must not block.\n"
"As described in <<blocking-processing>>, you need to add the `@Blocking` annotation on the method if this method will block the caller thread."
msgstr "La mensajería reactiva invoca los métodos del usuario en un hilo de E/S. Así, por defecto, los métodos no deben bloquearse. Como se describe en <<blocking-processing>> , es necesario añadir la anotación `@Blocking` en el método si éste va a bloquear el hilo de la llamada."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "Consulte la  link:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para obtener más detalles sobre este tema."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Channel Decorators"
msgstr "Decoradores de canales"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "SmallRye Reactive Messaging supports decorating incoming and outgoing channels for implementing cross-cutting concerns such as monitoring, tracing or message interception. For more information on implementing decorators and message interceptors see the http://smallrye.io/smallrye-reactive-messaging/latest/concepts/decorators/[SmallRye Reactive Messaging documentation]."
msgstr "SmallRye Reactive Messaging admite la decoración de canales entrantes y salientes para implementar preocupaciones transversales como la supervisión, el rastreo o la interceptación de mensajes. Para obtener más información sobre la implementación de decoradores e interceptores de mensajes, consulte la  link:http://smallrye.io/smallrye-reactive-messaging/3.19.1/concepts/decorators/[documentación de SmallRye Reactive] Messaging."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "Configuration Reference"
msgstr "Referencia de configuración"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/latest/kafka/kafka/#using-the-kafka-connector[SmallRye Reactive Messaging - Kafka Connector Documentation]."
msgstr "Puede encontrar más detalles sobre la configuración de SmallRye Reactive Messaging en la  link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[documentación de SmallRye Reactive Messaging - Kafka Connector]."

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Each channel can be disabled via configuration using:"
msgstr "Cada canal se puede desactivar mediante la configuración:"

#. type: delimited block =
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The most important attributes are listed in the tables below:"
msgstr "Los atributos más importantes se enumeran en las tablas siguientes:"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr "Configuración del canal de entrada (polling desde Kafka)"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The following attributes are configured using:"
msgstr "Los siguientes atributos se configuran utilizando:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Some properties have aliases which can be configured globally:"
msgstr "Algunas propiedades tienen alias que pueden configurarse globalmente:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#consumerconfigs[Kafka consumer]."
msgstr "También puede pasar cualquier propiedad soportada por el  link:https://kafka.apache.org/documentation/#consumerconfigs[consumidor Kafka] subyacente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For example, to configure the `max.poll.records` property, use:"
msgstr "Por ejemplo, para configurar la propiedad `max.poll.records`, utilice:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Some consumer client properties are configured to sensible default values:"
msgstr "Algunas propiedades del cliente consumidor están configuradas con valores sensibles por defecto:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If not set, `reconnect.backoff.max.ms` is set to `10000` to avoid high load on disconnection."
msgstr "Si no se configura, `reconnect.backoff.max.ms` se ajusta a `10000` para evitar una carga elevada en la desconexión."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If not set, `key.deserializer` is set to `org.apache.kafka.common.serialization.StringDeserializer`."
msgstr "Si no se establece, `key.deserializer` se fija en `org.apache.kafka.common.serialization.StringDeserializer`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The consumer `client.id` is configured according to the number of clients to create using `mp.messaging.incoming.[channel].partitions` property."
msgstr "El consumidor `client.id` se configura según el número de clientes a crear mediante la propiedad `mp.messaging.incoming.[channel].partitions`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If a `client.id` is provided, it is used as-is or suffixed with client index if `partitions` property is set."
msgstr "Si se proporciona un `client.id`, se utiliza tal cual o con el índice del cliente si se establece la propiedad `partitions`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If a `client.id` is not provided, it is generated as `[client-id-prefix][channel-name][-index]`."
msgstr "Si no se proporciona un `client.id`, se genera como `kafka-consumer-[channel][-index]`."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr "Configuración del canal de salida (escritura en Kafka)"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#producerconfigs[Kafka producer]."
msgstr "También puede pasar cualquier propiedad soportada por el  link:https://kafka.apache.org/documentation/#producerconfigs[productor Kafka] subyacente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For example, to configure the `max.block.ms` property, use:"
msgstr "Por ejemplo, para configurar la propiedad `max.block.ms`, utilice:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Some producer client properties are configured to sensible default values:"
msgstr "Algunas propiedades del cliente productor están configuradas con valores sensibles por defecto:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If not set, `key.serializer` is set to `org.apache.kafka.common.serialization.StringSerializer`."
msgstr "Si no se establece, `key.serializer` se fija en `org.apache.kafka.common.serialization.StringSerializer`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If not set, producer `client.id` is generated as `[client-id-prefix][channel-name]`."
msgstr "Si no se establece, el productor `client.id` se genera como `kafka-producer-[channel]`."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Kafka Configuration Resolution"
msgstr "Resolución de la configuración de Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.\n"
"This configuration is used to establish the connection with the Kafka broker."
msgstr "Quarkus expone todas las propiedades de la aplicación relacionadas con Kafka, prefijadas con `kafka.` o `KAFKA_` dentro de un mapa de configuración con el nombre `default-kafka-broker` . Esta configuración se utiliza para establecer la conexión con el broker Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "In addition to this default configuration, you can configure the name of the `Map` producer using the `kafka-configuration` attribute:"
msgstr "Además de esta configuración por defecto, puede configurar el nombre del productor de `Map` utilizando el atributo `kafka-configuration`:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In this case, the connector looks for the `Map` associated with the `my-configuration` name.\n"
"If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done."
msgstr "En este caso, el conector busca el `Map` asociado al nombre `my-configuration` . Si `kafka-configuration` no está configurado, se realiza una búsqueda opcional de un `Map` expuesto con el nombre del canal ( `my-channel` en el ejemplo anterior)."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If `kafka-configuration` is set and no `Map` can be found, the deployment fails."
msgstr "Si se establece `kafka-configuration` y no se encuentra ningún `Map`, el despliegue falla."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Attribute values are resolved as follows:"
msgstr "Los valores de los atributos se resuelven de la siguiente manera:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "the attribute is set directly on the channel configuration (`mp.messaging.incoming.my-channel.attribute=value`),"
msgstr "el atributo se establece directamente en la configuración del canal ( `mp.messaging.incoming.my-channel.attribute=value`),"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "if not set, the connector looks for a `Map` with the channel name or the configured `kafka-configuration` (if set) and the value is retrieved from that `Map`"
msgstr "si no se establece, el conector busca un `Map` con el nombre del canal o el `kafka-configuration` configurado (si se establece) y el valor se recupera de ese `Map`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the resolved `Map` does not contain the value the default `Map` is used (exposed with the `default-kafka-broker` name)"
msgstr "Si el `Map` resuelto no contiene el valor se utiliza el `Map` por defecto (expuesto con el nombre `default-kafka-broker` )"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Conditionally configure channels"
msgstr "Configurar canales condicionalmente"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"You can configure the channels using a specific profile.\n"
"Thus, the channels are only configured (and added to the application) when the specified profile is enabled."
msgstr "Puede configurar los canales utilizando un perfil específico. Así, los canales sólo se configuran (y se añaden a la aplicación) cuando el perfil especificado está activado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To achieve this, you need:"
msgstr "Para conseguirlo, necesitas:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Prefix the `mp.messaging.[incoming|outgoing].$channel` entries with `%my-profile` such as `%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value`"
msgstr "Prefijo para las entradas `mp.messaging.[incoming|outgoing].$channel` `%my-profile` como `%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Use the `@IfBuildProfile(\"my-profile\")` on the CDI beans containing `@Incoming(channel)` and `@Outgoing(channel)` annotations that need only to be enabled when the profile is enabled."
msgstr "Utilice el `@IfBuildProfile(\"my-profile\")` en los beans CDI que contienen anotaciones `@Incoming(channel)` y `@Outgoing(channel)` que sólo necesitan ser habilitadas cuando el perfil está habilitado."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Note that reactive messaging verifies that the graph is complete.\n"
"So, when using such a conditional configuration, ensure the application works with and without the profile enabled."
msgstr "Tenga en cuenta que la mensajería reactiva verifica que el grafo esté completo. Por lo tanto, cuando utilice una configuración condicional de este tipo, asegúrese de que la aplicación funciona con y sin el perfil activado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Note that this approach can also be used to change the channel configuration based on a profile."
msgstr "Tenga en cuenta que este enfoque también se puede utilizar para cambiar la configuración del canal en función de un perfil."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Integrating with Kafka - Common patterns"
msgstr "Integración con Kafka - Patrones comunes"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Writing to Kafka from an HTTP endpoint"
msgstr "Escribir en Kafka desde un punto final HTTP"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:"
msgstr "Para enviar mensajes a Kafka desde un endpoint HTTP, inyecte un `Emitter` (o un `MutinyEmitter`) en su endpoint:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Inject an `Emitter<String>`"
msgstr "Inyectar un `Emitter&amp;lt;String&amp;gt;`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka"
msgstr "El método HTTP recibe la carga útil y devuelve un `CompletionStage` completado cuando el mensaje se escribe en Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Send the message to Kafka, the `send` method returns a `CompletionStage`"
msgstr "Enviar el mensaje a Kafka, el método `send` devuelve un `CompletionStage`"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.\n"
"The emitter's channel is mapped to a Kafka topic in the `application.properties` file:"
msgstr "El punto final envía la carga útil pasada (de una solicitud HTTP `POST` ) al emisor. El canal del emisor se asigna a un tema Kafka en el archivo `application.properties` :"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.\n"
"The `emitter.send` method returns a `CompletionStage<Void>` .\n"
"The returned future is completed when the message has been written to Kafka.\n"
"If the writing fails, the returned `CompletionStage` is completed exceptionally."
msgstr "El punto final devuelve un `CompletionStage` que indica la naturaleza asíncrona del método. El método `emitter.send` devuelve un `CompletionStage<Void>` . El futuro devuelto se completa cuando el mensaje se ha escrito en Kafka. Si la escritura falla, el `CompletionStage` devuelto se completa excepcionalmente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user."
msgstr "Si el endpoint no devuelve un `CompletionStage`, la respuesta HTTP puede escribirse antes de que el mensaje se envíe a Kafka, por lo que los fallos no se comunicarán al usuario."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you need to send a Kafka record, use:"
msgstr "Si necesita enviar un registro Kafka, utilice"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Note the usage of an `Emitter<Record<K, V>>`"
msgstr "Obsérvese el uso de un `Emitter&amp;lt;Record&amp;lt;K, V&amp;gt;&amp;gt;`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Create the record using `Record.of(k, v)`"
msgstr "Cree el registro utilizando `Record.of(k, v)`"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate with Panache"
msgstr "Persistencia de mensajes Kafka con Hibernate con Panache"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate with Panache."
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate con Panache."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you use Hibernate Reactive, look at <<persisting-kafka-messages-with-hibernate-reactive>>."
msgstr "Si utiliza Hibernate Reactive, consulte <<persisting-kafka-messages-with-hibernate-reactive>> ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Let's imagine you receive `Fruit` objects.\n"
"For simplicity purposes, our `Fruit` class is pretty simple:"
msgstr "Imaginemos que recibe objetos `Fruit` . Para simplificar, nuestra clase `Fruit` es bastante sencilla:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:"
msgstr "Para consumir instancias de `Fruit` almacenadas en un tema de Kafka, y persistirlas en una base de datos, puede utilizar el siguiente enfoque:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Configuring the incoming channel. This channel reads from Kafka."
msgstr "Configurar el canal de entrada. Este canal lee de Kafka."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.\n"
"Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread)."
msgstr "Como estamos escribiendo en una base de datos, debemos estar en una transacción. Esta anotación inicia una nueva transacción y la consigna cuando el método retorna. Quarkus considera automáticamente que el método es _bloqueante_ . En efecto, escribir en una base de datos utilizando Hibernate clásico es bloqueante. Por lo tanto, Quarkus llama al método en un hilo de trabajo que puede bloquear (y no en un hilo de E/S)."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records."
msgstr "El método recibe cada Fruta. Tenga en cuenta que necesitaría un deserializador para reconstruir las instancias de Fruit a partir de los registros de Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Persist the received `fruit` object."
msgstr "Persiste el objeto `fruit` recibido."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"As mentioned in <4>, you need a deserializer that can create a `Fruit` from the record.\n"
"This can be done using a Jackson deserializer:"
msgstr "Como se mencionó en <4>, necesita un deserializador que pueda crear un `Fruit` a partir del registro. Esto puede hacerse utilizando un deserializador Jackson:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The associated configuration would be:"
msgstr "La configuración asociada sería:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Check <<jackson-serialization>> for more detail about the usage of Jackson with Kafka.\n"
"You can also use Avro."
msgstr "Consulte <<jackson-serialization>> para obtener más detalles sobre el uso de Jackson con Kafka. También puede utilizar Avro."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate Reactive"
msgstr "Persistencia de mensajes Kafka con Hibernate Reactive"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache."
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate Reactive con Panache."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Make sure to use the reactive variant"
msgstr "Asegúrese de utilizar la variante reactiva"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Inject the Hibernate Reactive `Session`"
msgstr "Inyecte el Hibernate Reactive `SessionFactory`."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Hibernate Reactive `Session` and `Panache` APIs require an active CDI Request context.\n"
"`@ActivateRequestContext` annotation creates a new request context and destroys it when the `Uni` returned from the method completes.\n"
"If `Panache` is not used, `Mutiny.SessionFactory` can be injected and used similarly without the need of activating the request context or closing the session manually."
msgstr "Las API de Hibernate Reactive `Session` y `Panache` requieren un contexto de solicitud CDI activo. La anotación `@ActivateRequestContext` crea un nuevo contexto de solicitud y lo destruye cuando se completa el `Uni` devuelto por el método. Si no se utiliza `Panache` , puede inyectarse `Mutiny.SessionFactory` y utilizarse de forma similar sin necesidad de activar el contexto de solicitud o cerrar la sesión manualmente."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Requests a new transaction. The transaction completes when the passed action completes."
msgstr "Indica a Panache que ejecute la acción dada (asíncrona) en una transacción. La transacción se completa cuando la acción se completa."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Persist the entity. It returns a `Uni<Fruit>`."
msgstr "Persiste la entidad. Devuelve un `Uni&amp;lt;Fruit&amp;gt;`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Switch back to a `Uni<Void>`."
msgstr "Vuelve a cambiar a un `Uni&amp;lt;Void&amp;gt;`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Close the session - this is close the connection with the database. The connection can then be recycled."
msgstr "Cerrar la sesión - esto es cerrar la conexión con la base de datos. La conexión puede entonces ser reciclada."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Unlike with _classic_ Hibernate, you can't use `@Transactional`.\n"
"Instead, we use `session.withTransaction` and persist our entity.\n"
"The `map` is used to return a `Uni<Void>` and not a `Uni<Fruit>`."
msgstr "A diferencia de lo que ocurre con Hibernate _clásico_ , no se puede utilizar `@Transactional` . En su lugar, utilizamos `session.withTransaction` y persistimos nuestra entidad. El `map` se utiliza para devolver un `Uni<Void>` y no un `Uni<Fruit>` ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"You need a deserializer that can create a `Fruit` from the record.\n"
"This can be done using a Jackson deserializer:"
msgstr "Necesita un deserializador que pueda crear un `Fruit` a partir del registro. Esto puede hacerse utilizando un deserializador Jackson:"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate to Kafka"
msgstr "Escritura de entidades gestionadas por Hibernate en Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Let's imagine the following process:"
msgstr "Imaginemos el siguiente proceso:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You receive an HTTP request with a payload,"
msgstr "Recibe una petición HTTP con una carga útil,"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You create an Hibernate entity instance from this payload,"
msgstr "Se crea una instancia de entidad Hibernate a partir de esta carga útil,"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You persist that entity into a database,"
msgstr "Se persiste esa entidad en una base de datos,"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You send the entity to a Kafka topic"
msgstr "Se envía la entidad a un tema Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you use Hibernate Reactive, look at <<writing-entities-managed-by-hibernate-reactive-to-kafka>>."
msgstr "Si utiliza Hibernate Reactive, consulte <<writing-entities-managed-by-hibernate-reactive-to-kafka>> ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Because we write to a database, we must run this method in a transaction.\n"
"Yet, sending the entity to Kafka happens asynchronously.\n"
"The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.\n"
"We must be sure that the transaction is still running until the object is written.\n"
"Otherwise, you may access the object outside the transaction, which is not allowed."
msgstr "Dado que escribimos en una base de datos, debemos ejecutar este método en una transacción. Sin embargo, el envío de la entidad a Kafka se produce de forma asíncrona. La operación devuelve un `CompletionStage` (o un `Uni` si utiliza un `MutinyEmitter` ) que informa cuando la operación finaliza. Debemos asegurarnos de que la transacción sigue en marcha hasta que se escribe el objeto. De lo contrario, se podría acceder al objeto fuera de la transacción, lo que no está permitido."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To implement this process, you need the following approach:"
msgstr "Para llevar a cabo este proceso, es necesario el siguiente enfoque:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "As we are writing to the database, make sure we run inside a transaction"
msgstr "Como estamos escribiendo en la base de datos, asegúrese de que se ejecuta dentro de una transacción"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka."
msgstr "El método recibe la instancia de la fruta a persistir. Devuelve un `CompletionStage` que se utiliza para la demarcación de la transacción. La transacción se compromete cuando se completa el retorno `CompletionStage`. En nuestro caso, es cuando el mensaje se escribe en Kafka."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Wrap the managed entity inside a Data transfer object and send it to Kafka.\n"
"This makes sure that managed entity is not impacted by the Kafka serialization."
msgstr "Envuelva la entidad gestionada dentro de un objeto de transferencia de datos y envíelo a Kafka. Esto asegura que la entidad gestionada no se vea impactada por la serialización de Kafka."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate Reactive to Kafka"
msgstr "Escritura de entidades gestionadas por Hibernate Reactive en Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To send to Kafka entities managed by Hibernate Reactive, we recommend using:"
msgstr "Para enviar a las entidades de Kafka gestionadas por Hibernate Reactive, se recomienda utilizar:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "RESTEasy Reactive to serve HTTP requests"
msgstr "RESTEasy Reactive para servir peticiones HTTP"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache."
msgstr "Un `MutinyEmitter` para enviar mensajes a un canal, por lo que se puede integrar fácilmente con la API Mutiny expuesta por Hibernate Reactive o Hibernate Reactive con Panache."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:"
msgstr "El siguiente ejemplo demuestra cómo recibir una carga útil, almacenarla en la base de datos utilizando Hibernate Reactive con Panache, y enviar la entidad persistente a Kafka:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Inyecta un `MutinyEmitter` que expone una API Mutiny. Simplifica la integración con la API Mutiny expuesta por Hibernate Reactive con Panache."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka)."
msgstr "El método HTTP que recibe la carga útil devuelve un `Uni&amp;lt;Void&amp;gt;`. La respuesta HTTP se escribe cuando la operación se completa (la entidad se persiste y se escribe en Kafka)."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "We need to write the entity into the database in a transaction."
msgstr "Necesitamos escribir la entidad en la base de datos en una transacción."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni<Void>`."
msgstr "Una vez completada la operación de persistencia, enviamos la entidad a Kafka. El método `send` devuelve un `Uni&amp;lt;Void&amp;gt;`."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Streaming Kafka topics as server-sent events"
msgstr "Transmisión de temas Kafka como eventos enviados por el servidor"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Streaming a Kafka topic as server-sent events (SSE) is straightforward:"
msgstr "La transmisión de un tema de Kafka como eventos enviados por el servidor (SSE) es sencilla:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You inject the channel representing the Kafka topic in your HTTP endpoint"
msgstr "Se inyecta el canal que representa el tema de Kafka en su punto final HTTP"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You return that channel as a `Publisher` or a `Multi` from the HTTP method"
msgstr "Se devuelve ese canal como un `Publisher` o un `Multi` desde el método HTTP"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The following code provides an example:"
msgstr "El siguiente código proporciona un ejemplo:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Some environment cuts the SSE connection when there is not enough activity.\n"
"The workaround consists of sending _ping_ messages (or empty objects) periodically."
msgstr "Algunos entornos cortan la conexión SSE cuando no hay suficiente actividad. La solución consiste en enviar mensajes _ping_ (u objetos vacíos) periódicamente."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.\n"
"To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds."
msgstr "La solución es un poco más compleja, ya que además de enviar los frutos procedentes de Kafka, necesitamos enviar pings periódicamente. Para ello fusionamos el flujo procedente de Kafka y un flujo periódico que emite `{}` cada 10 segundos."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Chaining Kafka Transactions with Hibernate Reactive transactions"
msgstr "Persistencia de mensajes Kafka con Hibernate Reactive"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"By chaining a Kafka transaction with a Hibernate Reactive transaction you can send records to a Kafka transaction,\n"
"perform database updates and commit the Kafka transaction only if the database transaction is successful."
msgstr "Encadenando una transacción de Kafka con una transacción reactiva de Hibernate puede enviar registros a una transacción de Kafka, realizar actualizaciones de la base de datos y consignar la transacción de Kafka sólo si la transacción de la base de datos tiene éxito."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The following example demonstrates:"
msgstr "El siguiente ejemplo lo demuestra:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Receive a payload by serving HTTP requests using RESTEasy Reactive,"
msgstr "Recibir una carga útil sirviendo peticiones HTTP utilizando RESTEasy Reactive,"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Limit concurrency of that HTTP endpoint using Smallrye Fault Tolerance,"
msgstr "Limitar la concurrencia de ese punto final HTTP utilizando Smallrye Fault Tolerance,"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Start a Kafka transaction and send the payload to Kafka record,"
msgstr "Iniciar una transacción Kafka y enviar la carga útil al registro Kafka,"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Store the payload in the database using Hibernate Reactive with Panache,"
msgstr "Para persistir los objetos recibidos de Kafka en una base de datos, puede utilizar Hibernate Reactive con Panache."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Commit the Kafka transaction only if the entity is persisted successfully."
msgstr "Compromete la transacción de Kafka sólo si la entidad se persiste con éxito."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Inject a `KafkaTransactions` which exposes a Mutiny API. It allows the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Inyecta un `MutinyEmitter` que expone una API Mutiny. Simplifica la integración con la API Mutiny expuesta por Hibernate Reactive con Panache."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Limit the concurrency of the HTTP endpoint to \"1\", preventing starting multiple transactions at a given time."
msgstr "Limita la concurrencia del extremo HTTP a \"1\", impidiendo el inicio de múltiples transacciones en un momento dado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and Kafka transaction is committed)."
msgstr "El método HTTP que recibe la carga útil devuelve un `Uni&amp;lt;Void&amp;gt;`. La respuesta HTTP se escribe cuando la operación se completa (la entidad se persiste y se escribe en Kafka)."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Begin a Kafka transaction."
msgstr "Probar una aplicación Kafka"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Send the payload to Kafka inside the Kafka transaction."
msgstr "Enviar la carga útil a Kafka dentro de la transacción Kafka."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Persist the entity into the database in a Hibernate Reactive transaction."
msgstr "Necesitamos escribir la entidad en la base de datos en una transacción."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Once the persist operation completes, and there is no errors, the Kafka transaction is committed.\n"
"The result is omitted and returned as the HTTP response."
msgstr "Una vez que la operación de persistencia se completa, y no hay errores, la transacción Kafka se compromete. El resultado se omite y se devuelve como respuesta HTTP."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In the previous example the database transaction (inner) will commit followed by the Kafka transaction (outer).\n"
"If you wish to commit the Kafka transaction first and the database transaction second, you need to nest them in the reverse order."
msgstr "En el ejemplo anterior, la transacción de base de datos (interna) se consignará seguida de la transacción de Kafka (externa). Si desea consignar primero la transacción de Kafka y después la de la base de datos, deberá anidarlas en el orden inverso."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The next example demonstrates that using the Hibernate Reactive API (without Panache):"
msgstr "El siguiente ejemplo demuestra que utilizando la API Reactiva de Hibernate (sin Panache):"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Inject the Hibernate Reactive `SessionFactory`."
msgstr "Inyecte el Hibernate Reactive `SessionFactory`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Capture the caller Vert.x context."
msgstr "Captura el contexto Vert.x de la persona que llama."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Begin a Hibernate Reactive transaction."
msgstr "Iniciar una transacción Hibernate Reactive."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Persist the payload and send the entity to Kafka."
msgstr "Se envía la entidad a un tema Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"The Kafka transaction terminates on the Kafka producer sender thread.\n"
"We need to switch to the Vert.x context previously captured in order to terminate the Hibernate Reactive transaction on the same context we started it."
msgstr "La transacción Kafka termina en el hilo emisor del productor Kafka. Necesitamos cambiar al contexto Vert.x capturado previamente para terminar la transacción Hibernate Reactive en el mismo contexto en el que la iniciamos."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Logging"
msgstr "Registro"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To reduce the amount of log written by the Kafka client, Quarkus sets the level of the following log categories to `WARNING`:"
msgstr "Para reducir la cantidad de registro escrito por el cliente Kafka, Quarkus establece el nivel de las siguientes categorías de registro en `WARNING`:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.apache.kafka.clients`"
msgstr "`org.apache.kafka.clients`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.apache.kafka.common.utils`"
msgstr "`org.apache.kafka.common.utils`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "`org.apache.kafka.common.metrics`"
msgstr "`org.apache.kafka.common.metrics`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You can override the configuration by adding the following lines to the `application.properties`:"
msgstr "Puede anular la configuración añadiendo las siguientes líneas a `application.properties`:"

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Connecting to Managed Kafka clusters"
msgstr "Conexión a clusters Kafka gestionados"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This section explains how to connect to notorious Kafka Cloud Services."
msgstr "Esta sección explica cómo conectarse a los notorios servicios en la nube de Kafka."

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Azure Event Hub"
msgstr "Azure Event Hub"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] provides an endpoint compatible with Apache Kafka."
msgstr "link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] proporciona un punto final compatible con Apache Kafka."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Azure Event Hubs for Kafka is not available in the _basic_ tier.\n"
"You need at least the _standard_ tier to use Kafka.\n"
"See https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs Pricing] to see the other options."
msgstr "Azure Event Hubs para Kafka no está disponible en el nivel _básico_ . Necesita al menos el nivel _estándar_ para utilizar Kafka. Consulte link:https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Precios de] Azure Event Hubs para ver las otras opciones."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To connect to Azure Event Hub, using the Kafka protocol with TLS, you need the following configuration:"
msgstr "Para conectarse a Azure Event Hub, utilizando el protocolo Kafka con TLS, se necesita la siguiente configuración:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The port is `9093`."
msgstr "El puerto es `9093`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "You need to use the JAAS `PlainLoginModule`."
msgstr "Es necesario utilizar el JAAS `PlainLoginModule`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The username is the `$ConnectionString` string."
msgstr "El nombre de usuario es la cadena `$ConnectionString`."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The Event Hub connection string given by Azure."
msgstr "La cadena de conexión del centro de eventos proporcionada por Azure."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Replace `<YOUR.EVENTHUBS.CONNECTION.STRING>` with the connection string for your Event Hubs namespace.\n"
"For instructions on getting the connection string, see https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Get an Event Hubs connection string].\n"
"The result would be something like:"
msgstr "Sustituya `<YOUR.EVENTHUBS.CONNECTION.STRING>` por la cadena de conexión de su espacio de nombres Event Hubs. Para obtener instrucciones sobre cómo obtener la cadena de conexión, consulte link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Obtener una] cadena de conexión de Event Hubs. El resultado sería algo como"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "This configuration can be global (as above), or set in the channel configuration:"
msgstr "Esta configuración puede ser global (como en el caso anterior), o establecerse en la configuración del canal:"

#. type: Title ===
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Red Hat OpenShift Streams for Apache Kafka"
msgstr "Red Hat OpenShift Streams para Apache Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"https://cloud.redhat.com/[Red Hat OpenShift Streams for Apache Kafka] provides managed Kafka brokers.\n"
"First, follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] to create your Kafka broker instance.\n"
"Make sure you copied the client id and client secret associated with the _ServiceAccount_ you created."
msgstr "Red Hat OpenShift link:https://cloud.redhat.com/[Streams] para Apache Kafka proporciona brokers de Kafka gestionados. En primer lugar, siga las instrucciones de link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Introducción a la CLI de rhoas para Red Hat OpenShift Streams para Apache Kafka] para crear su instancia de corredor de Kafka. Asegúrese de que ha copiado el id de cliente y el secreto de cliente asociados a la _ServiceAccount_ que ha creado."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Then, you can configure the Quarkus application to connect to the broker as follows:"
msgstr "A continuación, puede configurar la aplicación Quarkus para conectarse al broker de la siguiente manera:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The connection string, given on the admin console, such as `demo-c--bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`"
msgstr "La cadena de conexión, dada en la consola de administración, como `demo-c—​bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The kafka username (the client id from the service account)"
msgstr "El nombre de usuario de kafka (el identificador de cliente de la cuenta de servicio)"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "the kafka password (the client secret from the service account)"
msgstr "la contraseña de kafka (el secreto del cliente de la cuenta de servicio)"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "In general, these properties are prefixed using `%prod` to enable them only when running in production mode."
msgstr "En general, estas propiedades llevan el prefijo `%prod` para habilitarlas sólo cuando se ejecutan en modo de producción."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"As explained in https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], to use Red Hat OpenShift Streams for Apache Kafka, you must create the topic beforehand, create a _Service Account_, and provide permissions to read and write to your topic from that service account.\n"
"The authentication data (client id and secret) relates to the service account, which means you can implement fine-grain permissions and restrict access to the topic."
msgstr "Como se explica en link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Introducción a la CLI de rhoas para Red Hat OpenShift Streams para Apache Kafka] , para utilizar Red Hat OpenShift Streams para Apache Kafka, debe crear el tema de antemano, crear una cuenta de _servicio_ y proporcionar permisos para leer y escribir en su tema desde esa cuenta de servicio. Los datos de autenticación (id de cliente y secreto) se refieren a la cuenta de servicio, lo que significa que puede implementar permisos de grano fino y restringir el acceso al tema."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "When using Kubernetes, it is recommended to set the client id and secret in a Kubernetes secret:"
msgstr "Cuando se utiliza Kubernetes, se recomienda establecer el id de cliente y el secreto en un secreto de Kubernetes:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "To allow your Quarkus application to use that secret, add the following line to the `application.properties` file:"
msgstr "Para permitir que su aplicación Quarkus utilice ese secreto, añada la siguiente línea al archivo `application.properties`:"

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Red Hat OpenShift Service Registry"
msgstr "Red Hat OpenShift Streams para Apache Kafka"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry[Red Hat OpenShift Service Registry]\n"
"provides fully managed service registry for handling Kafka schemas."
msgstr "link:https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry[Red Hat OpenShift Service Registry] proporciona un registro de servicios totalmente gestionado para manejar los esquemas de Kafka."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"You can follow the instructions from\n"
"https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d[Getting started with Red Hat OpenShift Service Registry],\n"
"or use the `rhoas` CLI to create a new service registry instance:"
msgstr "Puede seguir las instrucciones de link:https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d[Introducción al registro de servicios de Red Hat OpenShift] o utilizar la CLI de `rhoas` para crear una nueva instancia de registro de servicios:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Make sure to note the _Registry URL_ of the instance created.\n"
"For authentication, you can use the same _ServiceAccount_ you created previously.\n"
"You need to make sure that it has the necessary permissions to access the service registry."
msgstr "Asegúrese de anotar la _URL del Registro_ de la instancia creada. Para la autenticación, puede utilizar la misma _ServiceAccount_ que creó anteriormente. Debe asegurarse de que dispone de los permisos necesarios para acceder al registro de servicios."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For example, using the `rhoas` CLI, you can grant the `MANAGER` role to the service account:"
msgstr "Por ejemplo, utilizando la CLI `rhoas`, puede conceder el rol `MANAGER` a la cuenta de servicio:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Then, you can configure the Quarkus application to connect to the schema registry as follows:"
msgstr "A continuación, puede configurar la aplicación Quarkus para conectarse al broker de la siguiente manera:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The service registry URL, given on the admin console, such as `https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2`"
msgstr "La URL del registro de servicios, dada en la consola de administración, como `&lt;a href=\"https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2\" class=\"bare\"&gt;https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2&lt;/a&gt;`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The OAuth token endpoint URL, such as `https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token`"
msgstr "La URL del punto final del token OAuth, como `&lt;a href=\"https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token\" class=\"bare\"&gt;https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token&lt;/a&gt;`"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The client id (from the service account)"
msgstr "El nombre de usuario de kafka (el identificador de cliente de la cuenta de servicio)"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "The client secret (from the service account)"
msgstr "la contraseña de kafka (el secreto del cliente de la cuenta de servicio)"

#. type: Title ====
#: _versions/main/guides/kafka.adoc
#, fuzzy, no-wrap
msgid "Binding Red Hat OpenShift managed services to Quarkus application using the Service Binding Operator"
msgstr "Vinculación de los servicios gestionados de Red Hat OpenShift a la aplicación Quarkus mediante el operador de vinculación de servicios"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"If your Quarkus application is deployed on a Kubernetes or OpenShift cluster with link:https://github.com/redhat-developer/service-binding-operator[Service Binding Operator] and link:https://github.com/redhat-developer/app-services-operator/tree/main/docs[OpenShift Application Services] operators installed,\n"
"configurations necessary to access Red Hat OpenShift Streams for Apache Kafka and Service Registry can be injected to the application using xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding]."
msgstr "Si su aplicación Quarkus se despliega en un clúster xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes] u OpenShift con los operadores Service link:https://github.com/redhat-developer/service-binding-operator[Binding Operator] y link:https://github.com/redhat-developer/app-services-operator/tree/main/docs[OpenShift Application Services] instalados, las configuraciones necesarias para acceder a Red Hat OpenShift Streams para Apache Kafka y Service Registry pueden inyectarse en la aplicación utilizando xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding] ."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"In order to set up the Service Binding, you need first to connect OpenShift managed services to your cluster.\n"
"For an OpenShift cluster you can follow the instructions from link:https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster[Connecting a Kafka and Service Registry instance to your OpenShift cluster]."
msgstr "Para configurar la vinculación de servicios, primero debe conectar los servicios gestionados de OpenShift a su clúster. Para un clúster OpenShift puede seguir las instrucciones de link:https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster[Conectar una instancia de Kafka y Registro de servicios a su clúster OpenShift] ."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "Once you've connected your cluster with the RHOAS Kafka and Service Registry instances, make sure you've granted necessary permissions to the newly created service account."
msgstr "Una vez que haya conectado su clúster con las instancias de RHOAS Kafka y Service Registry, asegúrese de que ha concedido los permisos necesarios a la cuenta de servicio recién creada."

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"Then, using the xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding] extension,\n"
"you can configure the Quarkus application to generate `ServiceBinding` resources for those services:"
msgstr "A continuación, utilizando la extensión xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding] , puede configurar la aplicación Quarkus para generar recursos `ServiceBinding` para esos servicios:"

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "For this example Quarkus build will generate the following `ServiceBinding` resources:"
msgstr "Para este ejemplo, Quarkus generará los siguientes recursos `ServiceBinding`:"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"You can follow xref:deploying-to-kubernetes.adoc#openshift[Deploying to OpenShift] to deploy your application, including generated `ServiceBinding` resources.\n"
"The configuration properties necessary to access the Kafka and Schema Registry instances will be injected to the application automatically at deployment."
msgstr "Puede seguir xref:deploying-to-kubernetes.adoc#openshift[Despliegue en OpenShift] para desplegar su aplicación, incluidos los recursos `ServiceBinding` generados. Las propiedades de configuración necesarias para acceder a las instancias de Kafka y Schema Registry se inyectarán en la aplicación automáticamente en el momento del despliegue."

#. type: Title ==
#: _versions/main/guides/kafka.adoc
#, no-wrap
msgid "Going further"
msgstr "Ir más allá"

#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid ""
"This guide has shown how you can interact with Kafka using Quarkus.\n"
"It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr "Esta guía ha mostrado cómo se puede interactuar con Kafka utilizando Quarkus. Utiliza SmallRye Reactive Messaging para construir aplicaciones de flujo de datos."

#. type: Plain text
#: _versions/main/guides/kafka.adoc
#, fuzzy
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "Si quieres ir más allá, consulta la documentación de  link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], la implementación utilizada en Quarkus."
